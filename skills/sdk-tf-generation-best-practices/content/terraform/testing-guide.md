---
short_description: Testing patterns for Speakeasy-generated Terraform providers
long_description: |
  Comprehensive guide to acceptance testing for Terraform providers generated by Speakeasy.
  Covers test infrastructure setup, ConfigDirectory pattern, testdata organization,
  resource sweepers, multi-version testing, use-case example testing, mock server testing
  for isolated unit tests, and CI/CD integration patterns.
source:
  repo: "planetscale/terraform-provider-planetscale, gravitee-io/terraform-provider-apim, opalsecurity/terraform-provider-opal, speakeasy-api/openapi-generation"
  path: "internal/provider/*_test.go, tests/examples/, zSDKs/terraform-provider-testing/internal/tfmockserver/"
  ref: "speakeasy, main"
  last_reconciled: "2025-12-11"
---

# Terraform Provider Testing Guide

This guide covers acceptance testing patterns for Speakeasy-generated Terraform providers, based on production patterns from real-world providers.

## Overview

Terraform provider testing has two categories:

| Type | Description | When to Use |
|------|-------------|-------------|
| **Manual** | Local testing with `dev_overrides` | Quick iteration during development |
| **Automated** | Go tests with real Terraform commands | CI/CD and regression testing |

Automated acceptance testing is essential for production providers.

## Test Infrastructure Setup

### Provider Test Foundation

Create `internal/provider/provider_test.go` with shared test infrastructure:

```go
package provider

import (
	"fmt"
	"math/rand"
	"os"
	"testing"

	"github.com/hashicorp/terraform-plugin-framework/providerserver"
	"github.com/hashicorp/terraform-plugin-go/tfprotov6"
)

// Test organization - use a dedicated test account
const testAccOrg = "your-test-organization"

// testAccProviders returns provider factories for acceptance tests
func testAccProviders() map[string]func() (tfprotov6.ProviderServer, error) {
	return map[string]func() (tfprotov6.ProviderServer, error){
		"yourprovider": providerserver.NewProtocol6WithError(New("test")()),
	}
}

// testAccPreCheck validates required environment variables
func testAccPreCheck(t *testing.T) {
	if os.Getenv("YOUR_API_TOKEN") == "" {
		t.Fatal("YOUR_API_TOKEN must be set for acceptance tests")
	}
	// Add additional required env vars
}

// randomWithPrefix generates unique resource names for parallel tests
func randomWithPrefix(prefix string) string {
	return fmt.Sprintf("%s-%d", prefix, rand.Intn(1000000))
}
```

### Add Test Dependency

In `.speakeasy/gen.yaml`, add the testing dependency:

```yaml
terraform:
  # ... other configuration ...
  additionalDependencies:
    github.com/hashicorp/terraform-plugin-testing: v1.13.3
```

## Config Patterns: Inline vs ConfigDirectory

There are two patterns for providing Terraform configurations in tests: **Inline Config** and **ConfigDirectory**. Choose based on your test requirements.

### When to Use Each Pattern

| Pattern | Use When | Advantages |
|---------|----------|------------|
| **Inline Config** | Mock server tests, dynamic server URLs, TestCase-level ProtoV6ProviderFactories | Full control over dynamic values, avoids provider conflicts |
| **ConfigDirectory** | Acceptance tests against real APIs, complex configurations, reusable configs | Separation of concerns, easier to maintain HCL |

> **Warning:** When using `ProtoV6ProviderFactories` at the TestCase level, `ConfigDirectory` with `ConfigVariables` can cause conflicts. The error `Providers must only be specified either at the TestCase or TestStep level` indicates this issue. Use inline Config strings instead.

### Inline Config Pattern

Use inline Config strings when you need dynamic values (like mock server URLs) or when ConfigDirectory causes provider conflicts:

```go
func TestResourceLifecycle(t *testing.T) {
    t.Parallel()

    server := mockserver.StartServer(endpoints, t)
    defer server.Close()

    resourceAddress := "myprovider_resource.test"

    resource.Test(t, resource.TestCase{
        ProtoV6ProviderFactories: testProviders(),
        Steps: []resource.TestStep{
            {
                Config: testResourceConfig(server.URL, "test-name"),
                Check: resource.ComposeAggregateTestCheckFunc(
                    resource.TestCheckResourceAttr(resourceAddress, "name", "test-name"),
                ),
            },
            // Import step
            {
                Config:            testResourceConfig(server.URL, "test-name"),
                ResourceName:      resourceAddress,
                ImportState:       true,
                ImportStateId:     "resource-id",
                ImportStateVerify: true,
            },
        },
    })
}

// Helper function generates HCL config with dynamic values
func testResourceConfig(serverURL, name string) string {
    return fmt.Sprintf(`
provider "myprovider" {
  server_url = %q
  bearer     = "test-token"
}

resource "myprovider_resource" "test" {
  name = %q
}
`, serverURL, name)
}
```

### ConfigDirectory Pattern

The ConfigDirectory pattern separates test logic from Terraform configurations, improving maintainability.

#### Directory Structure

```
internal/provider/
├── provider_test.go              # Shared test infrastructure
├── resource_test.go              # Resource test file
└── testdata/
    └── TestAccResourceName_Lifecycle/
        └── main.tf               # Terraform configuration
```

### Test Code Example

```go
func TestAccResourceName_Lifecycle(t *testing.T) {
	t.Parallel()  // Enable parallel test execution

	resourceName := randomWithPrefix("test-resource")
	resourceAddress := "yourprovider_resource.test"

	resource.Test(t, resource.TestCase{
		PreCheck:                 func() { testAccPreCheck(t) },
		ProtoV6ProviderFactories: testAccProviders(),
		Steps: []resource.TestStep{
			// Step 1: Create and verify
			{
				ConfigDirectory: config.TestNameDirectory(),
				ConfigVariables: config.Variables{
					"name":         config.StringVariable(resourceName),
					"organization": config.StringVariable(testAccOrg),
				},
				ConfigStateChecks: []statecheck.StateCheck{
					statecheck.ExpectKnownValue(
						resourceAddress,
						tfjsonpath.New("id"),
						knownvalue.NotNull(),
					),
					statecheck.ExpectKnownValue(
						resourceAddress,
						tfjsonpath.New("name"),
						knownvalue.StringExact(resourceName),
					),
				},
			},
			// Step 2: Import verification
			{
				ConfigDirectory: config.TestNameDirectory(),
				ConfigVariables: config.Variables{
					"name":         config.StringVariable(resourceName),
					"organization": config.StringVariable(testAccOrg),
				},
				ResourceName:      resourceAddress,
				ImportState:       true,
				ImportStateVerify: true,
			},
			// Step 3: Update (implicit delete at end)
			{
				ConfigDirectory: config.TestNameDirectory(),
				ConfigVariables: config.Variables{
					"name":         config.StringVariable(resourceName + "-updated"),
					"organization": config.StringVariable(testAccOrg),
				},
			},
		},
	})
}
```

### Testdata Configuration

Create `internal/provider/testdata/TestAccResourceName_Lifecycle/main.tf`:

```hcl
variable "name" {
  type = string
}

variable "organization" {
  type = string
}

resource "yourprovider_resource" "test" {
  name         = var.name
  organization = var.organization
}
```

## ConfigVariables for Parameterization

Use `ConfigVariables` to inject dynamic values into test configurations:

```go
ConfigVariables: config.Variables{
	"name":         config.StringVariable(resourceName),
	"count":        config.IntegerVariable(5),
	"enabled":      config.BoolVariable(true),
	"tags":         config.ListVariable(
		config.StringVariable("tag1"),
		config.StringVariable("tag2"),
	),
}
```

## State Checks

Verify resource state after each test step:

```go
ConfigStateChecks: []statecheck.StateCheck{
	// Check value is not null
	statecheck.ExpectKnownValue(
		resourceAddress,
		tfjsonpath.New("id"),
		knownvalue.NotNull(),
	),
	// Check exact string value
	statecheck.ExpectKnownValue(
		resourceAddress,
		tfjsonpath.New("status"),
		knownvalue.StringExact("active"),
	),
	// Check value matches regex
	statecheck.ExpectKnownValue(
		resourceAddress,
		tfjsonpath.New("id"),
		knownvalue.StringRegexp(regexp.MustCompile(`^[a-z0-9-]+$`)),
	),
	// Check sensitive values
	statecheck.ExpectSensitiveValue(
		resourceAddress,
		tfjsonpath.New("secret"),
	),
}
```

## Plan Checks

Verify plan behavior before apply:

```go
ConfigPlanChecks: resource.ConfigPlanChecks{
	PreApply: []plancheck.PlanCheck{
		plancheck.ExpectSensitiveValue(
			resourceAddress,
			tfjsonpath.New("password"),
		),
		plancheck.ExpectResourceAction(
			resourceAddress,
			plancheck.ResourceActionCreate,
		),
	},
},
```

## Resource Sweepers

Sweepers clean up resources from failed or interrupted tests. Essential for preventing orphaned infrastructure.

### Implementing a Sweeper

Create sweepers in `internal/provider/sweeper_test.go`:

```go
package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
)

func init() {
	resource.AddTestSweepers("yourprovider_resource", &resource.Sweeper{
		Name: "yourprovider_resource",
		F:    sweepResources,
		// Dependencies ensure sweep order
		Dependencies: []string{
			"yourprovider_child_resource",
		},
	})
}

func sweepResources(region string) error {
	ctx := context.Background()

	// Initialize client
	client, err := newTestClient()
	if err != nil {
		return fmt.Errorf("error creating client: %w", err)
	}

	// List resources with test prefix
	resources, err := client.ListResources(ctx)
	if err != nil {
		return fmt.Errorf("error listing resources: %w", err)
	}

	for _, r := range resources {
		// Only sweep test resources
		if !strings.HasPrefix(r.Name, "test-") && !strings.HasPrefix(r.Name, "testacc-") {
			continue
		}

		if err := client.DeleteResource(ctx, r.ID); err != nil {
			return fmt.Errorf("error deleting resource %s: %w", r.ID, err)
		}
	}

	return nil
}
```

### Running Sweepers

```bash
# Run all sweepers
go test ./... -v -sweep=all

# Run specific sweeper
go test ./... -v -sweep=yourprovider_resource

# Dry run (list what would be swept)
go test ./... -v -sweep=all -sweep-run=false
```

### Naming Conventions for Test Resources

Use consistent prefixes for test-created resources:

| Prefix | Purpose |
|--------|---------|
| `test-` | General test resources |
| `testacc-` | Acceptance test resources |
| `e2e-` | End-to-end test resources |

## Multi-Version Testing

Test against multiple Terraform and OpenTofu versions for compatibility.

### CI Matrix Strategy

`.github/workflows/test-extensive.yml`:

```yaml
name: extensive tests

on:
  push:
    branches: [main]
  pull_request:
    paths:
      - "**.go"

jobs:
  test-terraform:
    name: integration-terraform
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      fail-fast: false
      max-parallel: 1  # Sequential to avoid rate limits
      matrix:
        terraform:
          - "1.6.*"
          - "1.9.*"
          - latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: "go.mod"
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ matrix.terraform }}
          terraform_wrapper: false
      - run: make testacc
        env:
          YOUR_API_TOKEN: ${{ secrets.YOUR_API_TOKEN }}
        timeout-minutes: 10

  test-tofu:
    name: integration-tofu
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        tofu:
          - "1.6.*"
          - "1.7.*"
          - "1.8.*"
          - latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: "go.mod"
      - uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ matrix.tofu }}
          tofu_wrapper: false
      - run: make testacc
        env:
          YOUR_API_TOKEN: ${{ secrets.YOUR_API_TOKEN }}
        timeout-minutes: 10
```

### Tiered CI Strategy

Use two workflow files for efficiency:

| Workflow | Trigger | Tests |
|----------|---------|-------|
| `test.yml` | Every PR/push | Build, lint, unit tests |
| `test-extensive.yml` | Main branch, labeled PRs | Full matrix with acceptance tests |

## Makefile Targets

Standard targets for Terraform provider development:

```makefile
default: lint test

.PHONY: build
build:
	CGO_ENABLED=0 go build -v -trimpath .

.PHONY: generate
generate:
	speakeasy run --skip-versioning

.PHONY: lint
lint:
	golangci-lint run -v ./...

.PHONY: test
test:
	@echo "Running unit tests..."
	go test -v -cover ./...

.PHONY: testacc
testacc:
	TF_ACC=1 go test -parallel=2 ./... -v $(TESTARGS) -timeout 120m

.PHONY: sweep
sweep:
	go test ./... -v -sweep=all
```

## Running Tests

### Unit Tests

```bash
# Run all unit tests
go test -v ./...

# Run with coverage
go test -v -cover ./...

# Run specific test
go test -v -run TestResourceName ./...
```

### Acceptance Tests

> **Critical:** Tests using `resource.Test()` require `TF_ACC=1` to run. Without this environment variable, tests will be **silently skipped** with `PASS` status. This is a common source of confusion - tests appear to pass but never actually execute.

```bash
# REQUIRED: Set TF_ACC to enable acceptance tests
export TF_ACC=1

# Set API credentials
export YOUR_API_TOKEN="your-token"

# Run all acceptance tests
go test -v ./... -timeout 120m

# Run specific acceptance test
go test -v -run TestAccResourceName_Lifecycle ./... -timeout 30m

# Run with parallelism control
go test -parallel=2 -v ./... -timeout 120m

# One-liner with TF_ACC inline
TF_ACC=1 go test -v ./internal/provider/... -run TestResource
```

**Verifying tests actually ran:** Look for test output like `Step 1/2` or mock server logs. If tests pass instantly with no step output, `TF_ACC` is not set.

### Debug Mode

Run the provider in debug mode for step-through debugging:

```bash
go run main.go --debug

# Copy the TF_REATTACH_PROVIDERS env var from output
# In another terminal:
cd examples/your-example
TF_REATTACH_PROVIDERS='...' terraform init
TF_REATTACH_PROVIDERS='...' terraform apply
```

## Common Test Patterns

### Testing Resource Lifecycle

```go
Steps: []resource.TestStep{
	{Config: createConfig, /* verify create */},
	{Config: createConfig, ResourceName: addr, ImportState: true},
	{Config: updateConfig, /* verify update */},
	// Framework handles delete verification
}
```

### Testing Data Sources

```go
func TestAccDataSourceName(t *testing.T) {
	resource.Test(t, resource.TestCase{
		PreCheck:                 func() { testAccPreCheck(t) },
		ProtoV6ProviderFactories: testAccProviders(),
		Steps: []resource.TestStep{
			{
				ConfigDirectory: config.TestNameDirectory(),
				ConfigStateChecks: []statecheck.StateCheck{
					statecheck.ExpectKnownValue(
						"data.yourprovider_things.test",
						tfjsonpath.New("items"),
						knownvalue.NotNull(),
					),
				},
			},
		},
	})
}
```

### Testing Error Cases

```go
Steps: []resource.TestStep{
	{
		ConfigDirectory: config.TestNameDirectory(),
		ConfigVariables: config.Variables{
			"invalid_field": config.StringVariable("bad-value"),
		},
		ExpectError: regexp.MustCompile(`expected .* to be one of`),
	},
}
```

## Test Configuration Generators

For complex resources with many attributes, create configuration helper structs and generator functions. This pattern (used by the Opal provider) significantly reduces test boilerplate and makes test variations explicit.

### Configuration Struct Pattern

```go
// internal/provider/group_resource_test.go

// GroupConfig holds all configurable attributes for test generation
type GroupConfig struct {
	Name                 string
	Description          string
	GroupType            string
	AppID                string
	AdminOwnerID         string
	RequireMFAToApprove  string
	MaxDuration          string
	RequestConfigurations string
	Visibility           string
	Tags                 string
	// Add fields for all configurable attributes
}

// GenerateGroupResource creates HCL from the config struct
func GenerateGroupResource(cfg GroupConfig) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf(`
resource "opal_group" "test" {
  name        = %q
  group_type  = %q
  app_id      = %q
`, cfg.Name, cfg.GroupType, cfg.AppID))

	// Conditionally add optional fields
	if cfg.Description != "" {
		sb.WriteString(fmt.Sprintf("  description = %q\n", cfg.Description))
	}
	if cfg.AdminOwnerID != "" {
		sb.WriteString(fmt.Sprintf("  admin_owner_id = %q\n", cfg.AdminOwnerID))
	}
	if cfg.RequireMFAToApprove != "" {
		sb.WriteString(fmt.Sprintf("  require_mfa_to_approve = %s\n", cfg.RequireMFAToApprove))
	}
	if cfg.MaxDuration != "" {
		sb.WriteString(fmt.Sprintf("  max_duration = %s\n", cfg.MaxDuration))
	}
	if cfg.RequestConfigurations != "" {
		sb.WriteString(cfg.RequestConfigurations + "\n")
	}
	if cfg.Visibility != "" {
		sb.WriteString(cfg.Visibility + "\n")
	}
	if cfg.Tags != "" {
		sb.WriteString(cfg.Tags + "\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}
```

### Using Configuration Generators in Tests

```go
func TestAccGroup_CRUD(t *testing.T) {
	groupName := "tf-acc-test-" + acctest.RandHex(8)
	resourceName := "opal_group.test"

	resource.Test(t, resource.TestCase{
		PreCheck:                 func() { testAccPreCheck(t) },
		ProtoV6ProviderFactories: testAccProtoV6ProviderFactories,
		Steps: []resource.TestStep{
			// Step 1: Create with minimal config
			{
				Config: GenerateGroupResource(GroupConfig{
					Name:      groupName,
					GroupType: "OPAL_GROUP",
					AppID:     os.Getenv("OPAL_TEST_APP_ID"),
				}),
				Check: resource.ComposeTestCheckFunc(
					resource.TestCheckResourceAttr(resourceName, "name", groupName),
					resource.TestCheckResourceAttr(resourceName, "group_type", "OPAL_GROUP"),
				),
			},
			// Step 2: Update with additional attributes
			{
				Config: GenerateGroupResource(GroupConfig{
					Name:        groupName + "-updated",
					GroupType:   "OPAL_GROUP",
					AppID:       os.Getenv("OPAL_TEST_APP_ID"),
					Description: "Updated description",
					MaxDuration: "3600",
					Tags: `tags = {
						"env" = "test"
						"managed_by" = "terraform"
					}`,
				}),
				Check: resource.ComposeTestCheckFunc(
					resource.TestCheckResourceAttr(resourceName, "name", groupName+"-updated"),
					resource.TestCheckResourceAttr(resourceName, "description", "Updated description"),
					resource.TestCheckResourceAttr(resourceName, "tags.%", "2"),
				),
			},
		},
	})
}
```

### Benefits of Configuration Generators

| Benefit | Description |
|---------|-------------|
| **Reduced boilerplate** | Write HCL once, reuse across tests |
| **Explicit variations** | Test configurations are clearly parameterized |
| **Easy maintenance** | Update generator when schema changes |
| **Type safety** | Compiler catches missing required fields |

## Test Environment Setup

Production providers require comprehensive environment configuration for acceptance tests. Structure your test environment with known fixtures and clear documentation.

### Environment Variable Categories

```go
// internal/provider/provider_test.go

// Required for all tests
const (
	envAPIToken = "OPAL_AUTH_TOKEN"
)

// Required for resource-specific tests
const (
	envTestOrgID      = "OPAL_TEST_ORG_ID"
	envTestAppID      = "OPAL_TEST_APP_ID"
	envTestUserID     = "OPAL_TEST_USER_ID"
	envTestGroupID    = "OPAL_TEST_GROUP_ID"
	envTestResourceID = "OPAL_TEST_RESOURCE_ID"
	envTestOwnerID    = "OPAL_TEST_OWNER_ID"
)

// Optional overrides
const (
	envTestBaseURL = "OPAL_TEST_BASE_URL"
)
```

### Comprehensive PreCheck Function

```go
func testAccPreCheck(t *testing.T) {
	// Required environment variables
	required := []string{
		envAPIToken,
		envTestOrgID,
		envTestAppID,
	}

	var missing []string
	for _, env := range required {
		if os.Getenv(env) == "" {
			missing = append(missing, env)
		}
	}

	if len(missing) > 0 {
		t.Fatalf("Required environment variables not set: %s\n\n"+
			"To run acceptance tests, configure a test environment with:\n"+
			"  export %s=your-api-token\n"+
			"  export %s=your-test-org-id\n"+
			"  export %s=your-test-app-id\n\n"+
			"See CONTRIBUTING.md for test environment setup.",
			strings.Join(missing, ", "),
			envAPIToken, envTestOrgID, envTestAppID)
	}
}

// Resource-specific prechecks
func testAccPreCheckGroup(t *testing.T) {
	testAccPreCheck(t)
	if os.Getenv(envTestGroupID) == "" {
		t.Skipf("Skipping test: %s not set", envTestGroupID)
	}
}
```

### Test Fixture Documentation

Document required test fixtures in your repository:

```markdown
<!-- CONTRIBUTING.md or testing/README.md -->

## Test Environment Setup

### Required Fixtures

Create the following resources in a dedicated test organization:

| Environment Variable | Description | Example |
|---------------------|-------------|---------|
| `OPAL_AUTH_TOKEN` | API authentication token | `sk_test_...` |
| `OPAL_TEST_ORG_ID` | Test organization ID | `org_abc123` |
| `OPAL_TEST_APP_ID` | Pre-created application | `app_xyz789` |
| `OPAL_TEST_USER_ID` | Test user for assignments | `user_test1` |
| `OPAL_TEST_GROUP_ID` | Pre-created group for import tests | `grp_import` |

### CI/CD Secrets

Configure these as repository secrets:

```bash
gh secret set OPAL_AUTH_TOKEN --body "your-token"
gh secret set OPAL_TEST_ORG_ID --body "org_abc123"
# ... etc
```
```

### Parallel Test Safety

When running tests in parallel, ensure unique resource names:

```go
func TestAccGroup_Parallel(t *testing.T) {
	t.Parallel()  // Enable parallel execution

	// Use unique names to avoid conflicts
	groupName := fmt.Sprintf("tf-acc-%s-%d", t.Name(), rand.Intn(10000))

	// ... test implementation
}
```

---

## Use-Case Example Testing

Beyond unit and acceptance tests, test real-world usage examples to ensure documentation stays accurate and examples remain functional.

### Directory Structure

Organize use-case examples by resource type and scenario:

```
examples/
├── use-cases/                      # Real-world scenarios (auto-tested)
│   ├── {resource_type}-{scenario}/
│   │   ├── provider.tf
│   │   └── main.tf
│   ├── apiv4-proxy/
│   ├── apiv4-message/
│   ├── application-simple/
│   ├── application-oauth2/
│   └── subscription-basic/
└── resources/                      # Auto-generated (terraform-plugin-docs)
    └── example_resource/
        └── resource.tf
```

**Naming convention:** `{resource_type}-{scenario}`
- `database-basic` - Minimal database configuration
- `database-with-backups` - Database with backup configuration
- `user-admin-role` - User with admin permissions

### Example Test Harness

Create `tests/examples/example_usecases_test.go`:

```go
package examples_test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/hashicorp/terraform-plugin-framework/providerserver"
	"github.com/hashicorp/terraform-plugin-go/tfprotov6"
	"github.com/hashicorp/terraform-plugin-testing/config"
	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/yourorg/terraform-provider-example/internal/provider"
)

const examplesUseCasesDir = "examples/use-cases"
const examplesUseCasesPath = "../../" + examplesUseCasesDir

type testcase struct {
	name            string
	hrid            string
	directory       string
	resourceAddress string
	updateField     string
	updateValue     string
}

func TestUseCaseExamples(t *testing.T) {
	directories := listTestDirectories(examplesUseCasesPath)
	cases := createTestCases(t, directories)

	// Clean up any leftover state files
	cleanupTerraformStateFiles(directories)

	providers := testProviders()

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			t.Logf("Running test case: %s", tc.name)

			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: providers,
				Steps: []resource.TestStep{
					// Step 1: Create and verify
					{
						ConfigDirectory: config.StaticDirectory(tc.directory),
						ConfigVariables: config.Variables{
							"hrid": config.StringVariable(tc.hrid),
						},
					},
					// Step 2: Update (if applicable)
					{
						ConfigDirectory: config.StaticDirectory(tc.directory),
						ConfigVariables: config.Variables{
							"hrid":       config.StringVariable(tc.hrid),
							tc.updateField: config.StringVariable(tc.updateValue),
						},
					},
				},
			})
		})
	}
}

func listTestDirectories(basePath string) []string {
	var dirs []string
	err := filepath.Walk(basePath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() && path != basePath {
			// Skip directories with .testignore file
			if _, err := os.Stat(filepath.Join(path, ".testignore")); os.IsNotExist(err) {
				dirs = append(dirs, path)
			}
		}
		return nil
	})
	if err != nil {
		panic(err.Error())
	}
	return dirs
}

func createTestCases(t *testing.T, directories []string) []testcase {
	cases := make([]testcase, 0)
	for _, dir := range directories {
		testDir := filepath.Base(dir)

		// Parse resource type and scenario from directory name
		parts := strings.SplitN(testDir, "-", 2)
		if len(parts) != 2 {
			t.Logf("Skipping directory with invalid name format: %s", dir)
			continue
		}

		resourceType := parts[0]
		scenario := parts[1]
		hrid := scenario
		resourceAddress := "example_" + resourceType + "." + scenario

		cases = append(cases, testcase{
			name:            testDir,
			directory:       dir,
			resourceAddress: resourceAddress,
			hrid:            hrid,
			updateField:     "name",
			updateValue:     "updated-" + hrid,
		})
	}
	return cases
}

func cleanupTerraformStateFiles(directories []string) {
	for _, dir := range directories {
		files := []string{
			filepath.Join(dir, ".terraform"),
			filepath.Join(dir, "terraform.tfstate"),
			filepath.Join(dir, "terraform.tfstate.backup"),
			filepath.Join(dir, ".terraform.lock.hcl"),
		}
		for _, file := range files {
			os.RemoveAll(file)
		}
	}
}

func testProviders() map[string]func() (tfprotov6.ProviderServer, error) {
	return map[string]func() (tfprotov6.ProviderServer, error){
		"example": providerserver.NewProtocol6WithError(provider.New("test")()),
	}
}
```

### Skip Individual Examples

Create a `.testignore` file in any example directory to skip it during automated testing:

```bash
# examples/use-cases/database-experimental/.testignore
# This example requires manual setup and is not suitable for automated testing
```

### CI Integration for Example Tests

Add example tests to your CI workflow:

```yaml
# .github/workflows/acceptance.yaml
jobs:
  examples:
    name: Run Example Tests
    runs-on: ubuntu-latest
    needs: [pre-test-validation]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: "go.mod"
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.13.*"
          terraform_wrapper: false
      - name: Run example tests
        env:
          TF_ACC: 1
          YOUR_API_TOKEN: ${{ secrets.YOUR_API_TOKEN }}
        run: go test -v ./tests/examples/...
```

### Makefile Target

```makefile
.PHONY: examples-tests
examples-tests:
	TF_ACC=1 go test -v ./tests/examples/...
```

### Benefits of Use-Case Testing

| Benefit | Description |
|---------|-------------|
| **Documentation accuracy** | Examples are guaranteed to work |
| **Regression detection** | Catch breaking changes that affect real workflows |
| **Onboarding** | New users can trust example code |
| **Coverage** | Test complex multi-resource scenarios |

---

## Mock Server Testing

For isolated unit testing without external API dependencies, use an in-memory mock server. This pattern enables fast, deterministic tests that verify provider logic independently of API availability.

### When to Use Mock Server Testing

| Scenario | Approach |
|----------|----------|
| Local development iteration | Mock server |
| CI/CD unit tests | Mock server |
| Testing error handling | Mock server |
| Testing pagination | Mock server |
| Integration/acceptance tests | Real API |
| End-to-end validation | Real API |

### Mock Server Architecture

The mock server consists of two components:

1. **Server** - HTTP server that routes requests to handlers based on endpoint configuration
2. **Store** - In-memory data store that persists resource state across CRUD operations

```
┌─────────────────────────────────────────────────────────┐
│                    Mock Server                          │
├─────────────────────────────────────────────────────────┤
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐ │
│  │   Create    │    │    Get      │    │   Delete    │ │
│  │   Handler   │    │   Handler   │    │   Handler   │ │
│  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘ │
│         │                  │                  │        │
│         └──────────────────┼──────────────────┘        │
│                            │                           │
│                    ┌───────▼───────┐                   │
│                    │  In-Memory    │                   │
│                    │    Store      │                   │
│                    └───────────────┘                   │
└─────────────────────────────────────────────────────────┘
```

### Basic Mock Server Setup

Create a mock server package in your provider:

```go
// internal/mockserver/server.go
package mockserver

import (
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "sync"
    "testing"
)

const DefaultStoreKey = "default"

// ResourceEndpoints defines API endpoints for each CRUD operation
type ResourceEndpoints struct {
    Create Endpoints
    Get    Endpoints
    Update Endpoints
    Delete Endpoints
}

type Endpoints []*ResourceEndpoint

type ResourceEndpoint struct {
    // HTTP method and path, e.g., "POST /v1/resources" or "GET /v1/resources/{id}"
    Endpoint string

    // Static response (bypasses store)
    Response map[string]any

    // Overlay applied to store data in response
    ResponseOverlay map[string]any

    // Custom handler for complex scenarios (pagination, conditional responses)
    ResponseFunc func(r *http.Request, w http.ResponseWriter)

    // HTTP status code for not-found responses (default: 404)
    NotFoundStatusCode int

    // Captured requests for test assertions
    Requests RequestLog

    // Extracted path parameters
    params []string
}

// StartServer initializes and returns a mock HTTP server
func StartServer(endpoints ResourceEndpoints, t *testing.T) *httptest.Server {
    t.Helper()

    if err := endpoints.validate(); err != nil {
        t.Fatalf("invalid ResourceEndpoints: %v", err)
    }

    endpoints.setParams()
    endpoints.setStatusCodes()

    handler := &ResourceHandler{
        store:     NewStore(),
        endpoints: endpoints,
        t:         t,
    }

    server := httptest.NewServer(handler)
    t.Logf("Mock server started at: %s", server.URL)
    return server
}
```

### In-Memory Store

The store manages resource state with thread-safe operations:

```go
// internal/mockserver/store.go
package mockserver

import (
    "fmt"
    "sync"

    "github.com/google/uuid"
)

type Store struct {
    Data  map[string]map[string]any
    mutex sync.RWMutex
}

func NewStore() *Store {
    return &Store{
        Data: make(map[string]map[string]any),
    }
}

// Add stores data and returns a generated ID
func (s *Store) Add(data map[string]any) (string, error) {
    s.mutex.Lock()
    defer s.mutex.Unlock()

    id := uuid.New().String()
    s.Data[id] = deepCopy(data)
    return id, nil
}

// AddWithID stores data with a specific ID
func (s *Store) AddWithID(id string, data map[string]any) error {
    s.mutex.Lock()
    defer s.mutex.Unlock()

    if _, exists := s.Data[id]; exists {
        return fmt.Errorf("entry with ID %s already exists", id)
    }
    s.Data[id] = deepCopy(data)
    return nil
}

// Get retrieves data by ID
func (s *Store) Get(id string) (map[string]any, error) {
    s.mutex.RLock()
    defer s.mutex.RUnlock()

    data, exists := s.Data[id]
    if !exists {
        return nil, fmt.Errorf("entry with ID %s not found", id)
    }
    return deepCopy(data), nil
}

// Update performs a merge update on existing data
func (s *Store) Update(id string, data map[string]any) (map[string]any, error) {
    s.mutex.Lock()
    defer s.mutex.Unlock()

    existing, exists := s.Data[id]
    if !exists {
        return nil, fmt.Errorf("entry with ID %s not found", id)
    }

    // Merge: existing values + new values
    merged := deepCopy(existing)
    for k, v := range data {
        merged[k] = v
    }
    s.Data[id] = merged
    return deepCopy(merged), nil
}

// Delete removes data by ID
func (s *Store) Delete(id string) error {
    s.mutex.Lock()
    defer s.mutex.Unlock()

    if _, exists := s.Data[id]; !exists {
        return fmt.Errorf("entry with ID %s not found", id)
    }
    delete(s.Data, id)
    return nil
}

func deepCopy(data map[string]any) map[string]any {
    copy := make(map[string]any)
    for k, v := range data {
        copy[k] = v  // Add recursive copy for nested structures
    }
    return copy
}
```

### Request Capture for Assertions

Capture and inspect requests sent to the mock server:

```go
// internal/mockserver/requests.go
package mockserver

import "sync"

type CapturedRequest struct {
    Method     string
    Path       string
    PathParams map[string]string
    Body       map[string]any
}

type RequestLog struct {
    mu   sync.Mutex
    reqs []CapturedRequest
}

func (l *RequestLog) Append(req CapturedRequest) {
    l.mu.Lock()
    l.reqs = append(l.reqs, req)
    l.mu.Unlock()
}

func (l *RequestLog) All() []CapturedRequest {
    l.mu.Lock()
    defer l.mu.Unlock()
    out := make([]CapturedRequest, len(l.reqs))
    copy(out, l.reqs)
    return out
}

func (l *RequestLog) Bodies() []map[string]any {
    all := l.All()
    bodies := make([]map[string]any, len(all))
    for i, r := range all {
        bodies[i] = r.Body
    }
    return bodies
}
```

### Writing Mock Server Tests

#### Basic Lifecycle Test

Use inline Config strings for mock server tests to inject the dynamic server URL:

```go
func TestResourceLifecycle(t *testing.T) {
    t.Parallel()

    resourceID := "res-12345"
    responseOverlay := map[string]any{
        "id":     resourceID,
        "status": "active",
    }

    endpoints := mockserver.ResourceEndpoints{
        Create: mockserver.Endpoints{
            {
                Endpoint:        "POST /v1/resources",
                ResponseOverlay: responseOverlay,
            },
        },
        Get: mockserver.Endpoints{
            {
                Endpoint:        "GET /v1/resources/{id}",
                ResponseOverlay: responseOverlay,
            },
        },
        Delete: mockserver.Endpoints{
            {Endpoint: "DELETE /v1/resources/{id}"},
        },
    }

    server := mockserver.StartServer(endpoints, t)
    defer server.Close()

    resourceAddress := "myprovider_resource.test"

    resource.Test(t, resource.TestCase{
        ProtoV6ProviderFactories: testProviders(),
        Steps: []resource.TestStep{
            // Create and Read
            {
                Config: testResourceConfig(server.URL, "test-name"),
                Check: resource.ComposeAggregateTestCheckFunc(
                    resource.TestCheckResourceAttr(resourceAddress, "id", resourceID),
                    resource.TestCheckResourceAttr(resourceAddress, "name", "test-name"),
                ),
            },
            // Import
            {
                Config:            testResourceConfig(server.URL, "test-name"),
                ResourceName:      resourceAddress,
                ImportState:       true,
                ImportStateId:     resourceID,
                ImportStateVerify: true,
            },
        },
    })
}

// Helper function for inline config
func testResourceConfig(serverURL, name string) string {
    return fmt.Sprintf(`
provider "myprovider" {
  server_url = %q
  bearer     = "test-token"
}

resource "myprovider_resource" "test" {
  name = %q
}
`, serverURL, name)
}
```

#### Testing with Response Overlays

Use response overlays to add computed fields (like server-generated timestamps).

> **Critical:** When using `ResponseOverlay` with an `id` field, ensure the mock server stores resources using that ID. The Create handler must store resources with the overlay ID so subsequent GET requests can find them. Otherwise, you'll get 404 errors on the Read after Create:
> ```
> Error: unexpected response from API. Got an unexpected response code 404
> Request: GET /v1/resources/res-12345
> ```

The mock server should use the ResponseOverlay ID when storing:

```go
// In handleCreate: use overlay ID for storage
var id string
if overlayID, ok := ep.ResponseOverlay["id"].(string); ok && overlayID != "" {
    id = overlayID  // Use overlay ID so GET can find it
} else {
    id = generateID()
}
store.AddWithID(id, response)
```

**Complete example with computed fields:**

```go
func TestResourceWithComputedFields(t *testing.T) {
    t.Parallel()

    // Computed field values - same overlay for Create and Get
    createdAt := "2024-01-01T00:00:00Z"
    resourceID := "res-12345"

    responseOverlay := map[string]any{
        "id":         resourceID,
        "created_at": createdAt,
        "status":     "active",
    }

    endpoints := mockserver.ResourceEndpoints{
        Create: mockserver.Endpoints{
            {
                Endpoint:        "POST /v1/resources",
                ResponseOverlay: responseOverlay,
            },
        },
        Get: mockserver.Endpoints{
            {
                Endpoint:        "GET /v1/resources/{id}",
                ResponseOverlay: responseOverlay,
            },
        },
        Delete: mockserver.Endpoints{
            {Endpoint: "DELETE /v1/resources/{id}"},
        },
    }

    server := mockserver.StartServer(endpoints, t)
    defer server.Close()

    // Test verifies computed fields are populated correctly
    resource.Test(t, resource.TestCase{
        // ...
    })
}
```

#### Testing Error Scenarios

Use `ResponseFunc` to return custom error responses:

```go
func TestResourceConflictError(t *testing.T) {
    t.Parallel()

    endpoints := mockserver.ResourceEndpoints{
        Create: mockserver.Endpoints{
            {
                Endpoint: "POST /v1/resources",
                ResponseFunc: func(r *http.Request, w http.ResponseWriter) {
                    w.Header().Set("Content-Type", "application/json")
                    w.WriteHeader(409)
                    json.NewEncoder(w).Encode(map[string]any{
                        "error":   "conflict",
                        "message": "Resource with this name already exists",
                    })
                },
            },
        },
    }

    server := mockserver.StartServer(endpoints, t)
    defer server.Close()

    resource.Test(t, resource.TestCase{
        ProtoV6ProviderFactories: testProviders(),
        Steps: []resource.TestStep{
            {
                ConfigDirectory: config.TestNameDirectory(),
                ConfigVariables: config.Variables{
                    "server_url": config.StringVariable(server.URL),
                },
                ExpectError: regexp.MustCompile(`already exists`),
            },
        },
    })
}
```

#### Testing Pagination

Use `ResponseFunc` to simulate paginated responses:

```go
func TestResourcePagination(t *testing.T) {
    t.Parallel()

    callCount := 0

    endpoints := mockserver.ResourceEndpoints{
        Get: mockserver.Endpoints{
            {
                Endpoint: "GET /v1/resources",
                ResponseFunc: func(r *http.Request, w http.ResponseWriter) {
                    page := r.URL.Query().Get("page")
                    callCount++

                    var response map[string]any
                    switch page {
                    case "", "1":
                        response = map[string]any{
                            "items": []map[string]any{
                                {"id": "item-1", "name": "First"},
                                {"id": "item-2", "name": "Second"},
                            },
                            "next_page": "2",
                        }
                    case "2":
                        response = map[string]any{
                            "items": []map[string]any{
                                {"id": "item-3", "name": "Third"},
                            },
                            "next_page": nil,
                        }
                    }

                    w.Header().Set("Content-Type", "application/json")
                    w.WriteHeader(200)
                    json.NewEncoder(w).Encode(response)
                },
            },
        },
    }

    server := mockserver.StartServer(endpoints, t)
    defer server.Close()

    // Test and verify pagination was called multiple times
    // After test: assert callCount >= 2
}
```

### Verifying Request Bodies

Use captured requests to assert the provider sends correct data:

```go
func TestResourceSendsCorrectData(t *testing.T) {
    t.Parallel()

    createEndpoint := &mockserver.ResourceEndpoint{
        Endpoint: "POST /v1/resources",
    }

    endpoints := mockserver.ResourceEndpoints{
        Create: mockserver.Endpoints{createEndpoint},
        Get:    mockserver.Endpoints{{Endpoint: "GET /v1/resources/{id}"}},
        Delete: mockserver.Endpoints{{Endpoint: "DELETE /v1/resources/{id}"}},
    }

    server := mockserver.StartServer(endpoints, t)
    defer server.Close()

    resource.Test(t, resource.TestCase{
        ProtoV6ProviderFactories: testProviders(),
        Steps: []resource.TestStep{
            {
                ConfigDirectory: config.TestNameDirectory(),
                ConfigVariables: config.Variables{
                    "server_url": config.StringVariable(server.URL),
                    "name":       config.StringVariable("test-resource"),
                    "count":      config.IntegerVariable(5),
                },
            },
        },
    })

    // Assert request body after test
    captured := createEndpoint.Captured()
    if len(captured) != 1 {
        t.Fatalf("expected 1 create request, got %d", len(captured))
    }

    body := captured[0].Body
    if body["name"] != "test-resource" {
        t.Errorf("expected name 'test-resource', got %v", body["name"])
    }
    if body["count"] != float64(5) {
        t.Errorf("expected count 5, got %v", body["count"])
    }
}
```

### Endpoint Discovery

Before writing tests, verify exact API endpoints from your generated SDK:

```bash
# Find endpoint for CreateResource
grep -A 20 "func (s *SDK) CreateResource" internal/sdk/sdk.go

# Look for url.JoinPath or utils.GenerateURL lines to find exact paths
```

**Common endpoint pitfalls:**
- Plural vs singular paths (`/v1/resources` vs `/v1/resource`)
- Hyphenation (`/v1/resource-types` vs `/v1/resourcetypes`)
- Case sensitivity (`/v1/MyResource` vs `/v1/myresource`)

### Best Practices

| Practice | Description |
|----------|-------------|
| **Set `TF_ACC=1`** | Required for tests to run; without it tests silently skip |
| **Always verify endpoints** | Check generated SDK for exact paths before writing tests |
| **Use inline Config for mock tests** | Avoids provider conflicts with ProtoV6ProviderFactories |
| **Use `t.Parallel()`** | Enable parallel test execution for speed |
| **Defer `server.Close()`** | Ensure cleanup even on test failure |
| **Match overlay IDs with storage** | ResponseOverlay ID must match store key for GET to work |
| **Declare overlay variables** | Reuse response overlay values across Create and Get endpoints |
| **Test error paths** | Use `ResponseFunc` to verify error handling |
| **Capture requests** | Assert request bodies match expected schema |

### Test Directory Structure

```
internal/provider/
├── mockserver/                      # Mock server package
│   ├── server.go
│   ├── store.go
│   └── requests.go
├── resource_test.go                 # Resource tests
└── testdata/
    ├── TestResourceLifecycle/
    │   └── main.tf
    ├── TestResourceUpdate/
    │   └── main.tf
    └── TestResourceConflictError/
        └── main.tf
```

### Testdata Configuration Example

```hcl
# internal/provider/testdata/TestResourceLifecycle/main.tf
variable "server_url" {
  type = string
}

provider "myprovider" {
  server_url = var.server_url
}

resource "myprovider_resource" "test" {
  name = "test-resource"
}
```

---

## Pre-defined TODO List

When implementing acceptance tests for a Terraform provider:

| Step | TODO Item | Active Form |
|------|-----------|-------------|
| 1 | Add terraform-plugin-testing dependency to gen.yaml | Adding test dependency |
| 2 | Create provider_test.go with test infrastructure | Creating test infrastructure |
| 3 | Create testdata directory structure | Creating testdata structure |
| 4 | Write acceptance test for first resource | Writing first acceptance test |
| 5 | Implement resource sweeper | Implementing resource sweeper |
| 6 | Add PreCheck for required environment variables | Adding environment checks |
| 7 | Create examples/use-cases directory structure | Creating use-cases directory |
| 8 | Add use-case example test harness | Adding example test harness |
| 9 | Configure CI workflow for acceptance tests | Configuring CI workflow |
| 10 | Add multi-version test matrix (TF 1.10-1.13) | Adding version matrix |
| 11 | Run full acceptance test suite | Running acceptance tests |

**For mock server testing (isolated unit tests):**

| Step | TODO Item | Active Form |
|------|-----------|-------------|
| 12 | Create internal/mockserver package with server.go | Creating mock server package |
| 13 | Implement in-memory store (store.go) | Implementing in-memory store |
| 14 | Add request capture for assertions (requests.go) | Adding request capture |
| 15 | Verify exact endpoints from generated SDK | Verifying SDK endpoints |
| 16 | Write mock server tests for CRUD lifecycle | Writing mock server tests |
| 17 | Add response overlay tests for computed fields | Adding response overlay tests |
| 18 | Add ResponseFunc tests for error scenarios | Adding error scenario tests |
| 19 | Add pagination tests if applicable | Adding pagination tests |

**Usage:**
```
TodoWrite([
  {content: "Add terraform-plugin-testing dependency to gen.yaml", status: "pending", activeForm: "Adding test dependency"},
  {content: "Create provider_test.go with test infrastructure", status: "pending", activeForm: "Creating test infrastructure"},
  {content: "Create testdata directory structure", status: "pending", activeForm: "Creating testdata structure"},
  {content: "Write acceptance test for first resource", status: "pending", activeForm: "Writing first acceptance test"},
  {content: "Implement resource sweeper", status: "pending", activeForm: "Implementing resource sweeper"},
  {content: "Add PreCheck for required environment variables", status: "pending", activeForm: "Adding environment checks"},
  {content: "Create examples/use-cases directory structure", status: "pending", activeForm: "Creating use-cases directory"},
  {content: "Add use-case example test harness", status: "pending", activeForm: "Adding example test harness"},
  {content: "Configure CI workflow for acceptance tests", status: "pending", activeForm: "Configuring CI workflow"},
  {content: "Add multi-version test matrix (TF 1.10-1.13)", status: "pending", activeForm: "Adding version matrix"},
  {content: "Run full acceptance test suite", status: "pending", activeForm: "Running acceptance tests"},
  {content: "Create internal/mockserver package with server.go", status: "pending", activeForm: "Creating mock server package"},
  {content: "Implement in-memory store (store.go)", status: "pending", activeForm: "Implementing in-memory store"},
  {content: "Add request capture for assertions (requests.go)", status: "pending", activeForm: "Adding request capture"},
  {content: "Verify exact endpoints from generated SDK", status: "pending", activeForm: "Verifying SDK endpoints"},
  {content: "Write mock server tests for CRUD lifecycle", status: "pending", activeForm: "Writing mock server tests"},
  {content: "Add response overlay tests for computed fields", status: "pending", activeForm: "Adding response overlay tests"},
  {content: "Add ResponseFunc tests for error scenarios", status: "pending", activeForm: "Adding error scenario tests"},
  {content: "Add pagination tests if applicable", status: "pending", activeForm: "Adding pagination tests"}
])
```

**Conditional steps:**
- Steps 12-19 (mock server): Use when testing without external API access
- Step 5 (sweeper): Only for providers with external resources to clean up
- Step 19 (pagination): Only for resources with paginated list operations

**Related guides:**
- `terraform/customization.md` - Provider customization options
- `terraform/publishing.md` - Publishing to Terraform Registry
- `plans/tf-provider-generation.md` - Provider generation workflow
