---
short_description: Customize Terraform providers with extensions and configurations
long_description: |
  Comprehensive guide to customizing Terraform providers generated by Speakeasy, covering
  entity mapping, provider configuration, resource configuration, property customization,
  validation, plan modification, testing, and troubleshooting.
source:
  repo: "speakeasy-api/speakeasy.com, opalsecurity/terraform-provider-opal"
  path: |
    src/content/docs/terraform/customize/index.mdx
    src/content/docs/terraform/customize/entity-mapping.mdx
    src/content/docs/terraform/customize/property-customization.mdx
    src/content/docs/terraform/customize/provider-configuration.mdx
    src/content/docs/terraform/customize/resource-configuration.mdx
    src/content/docs/terraform/customize/advanced-features.mdx
    src/content/docs/terraform/customize/validation-dependencies.mdx
    src/content/docs/terraform/customize/plan-modification.mdx
    src/content/docs/terraform/customize/schema-keywords.mdx
    src/content/docs/terraform/customize/testing.mdx
    src/content/docs/terraform/customize/common-troubleshooting.mdx
    src/content/docs/speakeasy-reference/generation/terraform-config.mdx
    terraform_overlay.yaml, internal/stateupgraders/, Makefile
  ref: "af7c36a9ec957336fb799151a4e5af3ae293831e"
  last_reconciled: "2025-12-11"
---

# Customize Your Terraform Provider

Speakeasy provides various extensions and configurations to customize your Terraform provider. These customizations allow you to:

- Map API entities and operations to Terraform resources
- Enable provider-level configurations and environment values
- Customize validation and plan modification
- And more

## Entity Mapping

Add the `x-speakeasy-entity` extension to objects in your OpenAPI Specification document to include them as entities in the Terraform provider, such as managed resources. The extension value may be a single string or an array of strings if the object should be represented by multiple API entities.

As a component:

```yaml
components:
  schemas:
    Order:
      description: An order helps you make coffee
      x-speakeasy-entity: Order
      properties:
        id:
          type: integer
          description: Numeric identifier of the order.
        name:
          type: string
          description: Product name of the coffee.
        price:
          type: number
          description: Suggested cost of the coffee.
      required:
        - name
        - price
      type: object
```

Or inline in a path:

```yaml
paths:
  /order:
    post:
      tags:
        - Order
      summary: Create a coffee order
      x-speakeasy-entity-operation: Order#create
      requestBody:
        content:
          application/json:
            schema:
              x-speakeasy-entity: Order
              properties:
                id:
                  type: integer
                  description: Numeric identifier of the order.
                name:
                  type: string
                  description: Product name of the coffee.
                price:
                  type: number
                  description: Suggested cost of the coffee.
              required:
                - name
                - price
              type: object
```

```hcl
resource "yourprovider_order" "example" {
  name  = "Filter Blend"
  price = 11.5
}
```

Where you place the `x-speakeasy-entity` annotation affects the Terraform resource schema structure.

- **At the top level:** Properties are nested objects.
- **At a lower level:** Properties above the annotation are flattened.

### Top Level

```yaml
Pet:
  x-speakeasy-entity: Order
  type: object
  properties:
    data:
      type: object
      properties:
        name:
          type: string
        # ...
```

Results in the following resource schema and configuration:

```hcl
resource "yourprovider_order" "example" {
  data = {
    name = "Filter Blend"
  }
}
```

### Lower Level

```yaml
Pet:
  type: object
  properties:
    data:
      x-speakeasy-entity: Order
      type: object
      properties:
        name:
          type: string
        #...
```

Results in the following resource schema and configuration:

```hcl
resource "yourprovider_order" "example" {
  name = "Filter Blend"
}
```

> **Warning:** Properties above the `x-speakeasy-entity` annotation are flattened, which could cause conflicts. Apply the annotation carefully to align the structure of the Terraform provider with the API's intended interaction.

## Specify CRUD Operations for API Endpoints

The `x-speakeasy-entity-operation` annotation specifies CRUD (create, read, update, and delete) operations associated with each endpoint in the OpenAPI spec for a Terraform entity. The value determines the behavior of operations such as create, read, update, and delete and is structured as `Entity#operation,operation,...#order`:

- `Entity` represents the name of the entity.
- `operation` can be one or more of `create`, `read`, `update`, and `delete`, concatenated with commas.
- `order` is optional and can be used to define additional API calls that should be invoked for a given CRUD invocation.

> **Warning:** Only `create`, `read`, `update`, and `delete` are valid operation types. Using invalid types like `#list` will cause validation errors. For list endpoints, either omit `x-speakeasy-entity-operation` or use a plural entity name with `#read` (e.g., `Pets#read` for a data source).

### Behavior of Operations

- `Entity#create` makes the entity a Terraform resource.
- `Entity#read` ensures consistency with Terraform state, updates attributes, and generates a data source.
- `Entity#update` provides update support for the resource. Without it, any attribute change requires resource replacement (`ForceNew`).
- `Entity#delete` enables deletion of the resource. Without it, no action is taken on deletion.
- `Entity#create,update` **(idempotent operations)** indicates the API is idempotent. Combine these operations to allow the same API call to create new objects and update existing ones, depending on attribute changes.

In this example, a Pet managed resource with full create, read, update, and delete lifecycle and Pet data resource (due to `Pet#read`) are defined:

```yaml
paths:
  /pet:
    post:
      tags:
        - pet
      summary: Add a new pet to the store
      x-speakeasy-entity-operation: Pet#create
  /pet/{petId}:
    get:
      tags:
        - pet
      summary: Info for a specific pet
      x-speakeasy-entity-operation: Pet#read
    put:
      tags:
        - pet
      summary: Update the pet
      x-speakeasy-entity-operation: Pet#update
    delete:
      tags:
        - pet
      summary: Delete the pet
      x-speakeasy-entity-operation: Pet#delete
```

> **Note:** Terraform generation automatically handles pagination implementation details via the `x-speakeasy-pagination` extension. This includes paging through all responses and removing unnecessary pagination handling properties from the schema.

In this example, an automatically paginated Pets data resource is defined:

```yaml
paths:
  /pet:
    get:
      tags:
        - pet
      summary: Lists all pets
      x-speakeasy-entity-operation: Pets#read
      x-speakeasy-pagination:
        type: offsetLimit
        inputs:
          - name: page
            in: parameters
            type: page
        outputs:
          results: $.results
```

### Multiple API Operations for One Resource

When multiple API operations are necessary for a single resource, use the additional entity-ordering capabilities of the `x-speakeasy-entity-operation` annotation.

```yaml
paths:
  /pet/{petId}:
    get:
      x-speakeasy-entity-operation: Pet#read#1
  /animal:
    get:
      x-speakeasy-entity-operation: Pet#read#2
```

Multiple API operations for one resource can be combined with multiple entity operations of one API operation for multiple resources as necessary.

#### Real-World Example: Complex Entity with Multiple Read Endpoints

Production APIs often require 4+ API calls to fully populate a Terraform resource. Here's a pattern from the Opal provider where a `Group` resource requires data from multiple endpoints:

```yaml
# overlay-group.yaml
overlay: 1.1.0
x-speakeasy-jsonpath: rfc9535
info:
  title: Group entity overlay
actions:
  # Primary group endpoint - basic info
  - target: $["paths"]["/groups/{group_id}"]["get"]
    update:
      x-speakeasy-entity-operation: Group#read#1

  # Group visibility settings from separate endpoint
  - target: $["paths"]["/groups/{group_id}/visibility"]["get"]
    update:
      x-speakeasy-entity-operation: Group#read#2

  # Group reviewers from another endpoint
  - target: $["paths"]["/groups/{group_id}/reviewers"]["get"]
    update:
      x-speakeasy-entity-operation: Group#read#3

  # Group message channels
  - target: $["paths"]["/groups/{group_id}/message-channels"]["get"]
    update:
      x-speakeasy-entity-operation: Group#read#4

  # CRUD operations follow the same pattern
  - target: $["paths"]["/groups"]["post"]
    update:
      x-speakeasy-entity-operation: Group#create

  - target: $["paths"]["/groups"]["put"]
    update:
      x-speakeasy-entity-operation: Group#update

  - target: $["paths"]["/groups/{group_id}"]["delete"]
    update:
      x-speakeasy-entity-operation: Group#delete

  # Secondary update endpoints for related data
  - target: $["paths"]["/groups/{group_id}/visibility"]["put"]
    update:
      x-speakeasy-entity-operation: Group#update#2

  - target: $["paths"]["/groups/{group_id}/reviewers"]["put"]
    update:
      x-speakeasy-entity-operation: Group#update#3
```

**Key patterns demonstrated:**
- `#read#1` through `#read#4` aggregates data from multiple GET endpoints
- `#update#2`, `#update#3` handles updates across multiple PUT endpoints
- All operations share the same entity name (`Group`)

### One API Operation for Multiple Resources

When a single API operation is necessary for multiple resources, use multiple entity operation entries with the `x-speakeasy-entity-operation` annotation.

```yaml
parameters:
  - in: query
    name: id
    required: false
    schema:
      type: string
operationId: GetAnimal
x-speakeasy-entity-operation:
  - Cat#read
  - Dog#read
```

One API operation for multiple resources can be combined with the entity operation ordering of multiple API operations for one resource as necessary.

### API Operation Polling

Define automatic API operation polling logic for APIs with asynchronous behaviors via the `x-speakeasy-polling` and `x-speakeasy-entity-operation` extensions in the OpenAPI Specification document.

#### Basic Polling Configuration

In this example:

```yaml
/task:
  post:
    x-speakeasy-entity-operation: Task#create#1
/task/{id}:
  get:
    responses:
      "200":
        description: OK
        content:
          application/json:
            schema:
              type: object
              properties:
                name:
                  type: string
                status:
                  type: string
                  enum:
                    - completed
                    - errored
                    - pending
                    - running
              required:
                - name
                - status
    x-speakeasy-polling:
      - name: WaitForCompleted
        failureCriteria:
          - condition: $statusCode == 200
          - condition: $response.body#/status == "errored"
        successCriteria:
          - condition: $statusCode == 200
          - condition: $response.body#/status == "completed"
    x-speakeasy-entity-operation:
      - Task#read
      - entityOperation: Task#create#2
        options:
          polling:
            name: WaitForCompleted
```

The API operation is used for both the read operation and the second create operation, where the second create operation will use the `WaitForCompleted` polling method to ensure the success criteria is met before the resource logic (and therefore Terraform) continues.

#### Polling Criteria Syntax

Polling conditions use JSONPath-like selectors:

| Selector | Description | Example |
|----------|-------------|---------|
| `$statusCode` | HTTP response status code | `$statusCode == 200` |
| `$response.body#/path/to/field` | JSON path into response body | `$response.body#/status/phase == "READY"` |

**Success criteria** - All conditions must be true for polling to complete successfully.

**Failure criteria** - If all conditions match, polling fails immediately with an error.

#### Polling Timing Configuration

There are `delaySeconds`, `intervalSeconds`, and `limitCount` configurations to control polling timing:

| Option | Description | Default |
|--------|-------------|---------|
| `delaySeconds` | Seconds before first polling attempt | 0 |
| `intervalSeconds` | Seconds between polling attempts | 5 |
| `limitCount` | Maximum polling attempts before timeout | 60 |

In this example:

```yaml
/task/{id}:
  get:
    x-speakeasy-polling:
      - name: WaitForCompleted
        failureCriteria:
          - condition: $statusCode == 200
          - condition: $response.body#/status == "errored"
        intervalSeconds: 5
        successCriteria:
          - condition: $statusCode == 200
          - condition: $response.body#/status == "completed"
    x-speakeasy-entity-operation:
      - Task#read
      - entityOperation: Task#create#2
        options:
          polling:
            name: WaitForCompleted
            intervalSeconds: 10
```

The `WaitForCompleted` polling method for the API operation defaults to a 5 second interval, however the create entity operation overrides to a 10 second interval.

#### Real-World Polling Example: Kafka Cluster Provisioning

This example from the Confluent provider shows polling for cluster provisioning with phase-based status:

```yaml
# overlay-terraform-cmk-cluster.yaml
- target: $.paths["/cmk/v2/clusters/{id}"].get
  update:
    x-speakeasy-entity-operation:
      - KafkaCluster#read
      - entityOperation: KafkaCluster#create#2
        options:
          polling:
            delaySeconds: 2      # Wait 2 seconds before first poll
            intervalSeconds: 2   # Poll every 2 seconds
            limitCount: 120      # Max 120 attempts (4 minutes total)
            name: WaitForProvisioned
    x-speakeasy-polling:
      - name: WaitForProvisioned
        failureCriteria:
          - condition: $statusCode == 200
          - condition: $response.body#/status/phase == "FAILED"
        successCriteria:
          - condition: $statusCode == 200
          - condition: $response.body#/status/phase == "PROVISIONED"
```

**Key patterns demonstrated:**
- `#create#2` chains polling after the initial create call
- Phase-based status checking (`PROVISIONED`, `FAILED`)
- Conservative timing (2-second intervals, 4-minute timeout)

#### Generated Polling Infrastructure

When you configure polling, Speakeasy generates a `polling/` package in the SDK:

```go
// internal/sdk/polling/config.go
type Config struct {
    DelaySeconds    *int    // Seconds before first poll
    IntervalSeconds *int    // Seconds between polls
    LimitCount      *int    // Max poll attempts
    Name            string  // Polling configuration name
}

// internal/sdk/polling/errors.go
type FailureCriteriaError struct {
    Message string
}

type LimitCountError struct {
    Limit int
}
```

The resource implementation uses polling options:

```go
// In resource Create method
getCmkV2ClusterOptions := make([]operations.Option, 0, 1)
getCmkV2ClusterOptions = append(getCmkV2ClusterOptions, operations.WithPolling(
    r.client.ClustersCmkV2.GetCmkV2ClusterWaitForProvisioned(),
    polling.WithDelaySecondsOverride(2),
    polling.WithIntervalSecondsOverride(2),
    polling.WithLimitCountOverride(120),
))
res, err := r.client.ClustersCmkV2.GetCmkV2Cluster(ctx, request, getCmkV2ClusterOptions...)
```

> **Pattern Source:** Extracted from [speakeasy-sdks/terraform-provider-confluent](https://github.com/speakeasy-sdks/terraform-provider-confluent) - Kafka cluster provisioning with phase-based polling

### Manual Association Between Operations and Resource / Data Sources

The default behavior within Speakeasy is to automatically infer a data source from all operations that have an `x-speakeasy-entity-operation: Entity#read` association defined.

For some APIs, you might want the data source to use a "search" endpoint (e.g., search for an entity by name, where name is non-unique), while using a "get" operation for the resource (e.g., to find an entity by ID for state reconciliation).

In this case, use an object syntax for the `x-speakeasy-entity-operation` annotation to explicitly control whether an operation generates a resource, a data source, or both:

```yaml
paths:
  "/example":
    get:
      operationId: getThing
      x-speakeasy-entity-operation:
        terraform-datasource: null
        terraform-resource: Thing#read
```

This syntax allows you to:

- Prevent automatic generation of a data source by setting `terraform-datasource` to `null`
- Prevent invocation of the operation during the resource's Read method by setting `terraform-resource` to `null`

For example, the configuration above declares that `getThing` is associated with just a resource, and a data source should not be automatically generated.

### Wrapping Additional API Operation Response Data

When defining multiple API operations for a single entity, an API definition may be written such that those API operation response are a flattened object. When adding those additional operations to the entity, those flattened object properties are added to the top level of the resource schema by default.

Use `x-speakeasy-wrapped-attribute` extension to override this behavior, which will create a wrapping attribute that contains the underlying object properties in the final resource schema.

In this example, the resource will put the second API operation response properties underneath a `subconfig` attribute:

```yaml
paths:
  /example/{id}:
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: string
    get:
      x-speakeasy-entity-operation: Example#read
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ExampleResponse"
  /example/{id}/subconfig:
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: string
    get:
      x-speakeasy-entity-operation: Example#read#2
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                allOf:
                  - $ref: "#/components/schemas/ExampleSubconfigResponse"
                  - x-speakeasy-wrapped-attribute: subconfig
```

### Array Response Wrapping

Terraform resources require an object-type root schema. When an API returns an array, Speakeasy automatically wraps it in an attribute (default name: `data`).

**Default behavior:**

```yaml
paths:
  /things:
    get:
      x-speakeasy-entity-operation: Things#read
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                type: array
                items:
                  x-speakeasy-entity: Things
```

Since the response is `type: array`, Speakeasy wraps it in a `data` attribute for Terraform compatibility.

Access in Terraform:

```hcl
data.example_things.data[0].id
```

**Customize the wrapper name:**

```yaml
paths:
  /things:
    get:
      x-speakeasy-entity-operation: Things#read
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                x-speakeasy-wrapped-attribute: items
                type: array
                items:
                  x-speakeasy-entity: Things
```

Now the wrapping attribute is named `items` instead:

```hcl
data.example_things.items[0].id
```

> **Note:** The wrapping attribute name is a Terraform construct created by Speakeasy, completely separate from your API's response structure. Use `x-speakeasy-wrapped-attribute` to customize it.

### Resources with Soft Delete

By default, a generated managed resource uses the HTTP 404 Not Found status code on read to automatically remove the resource from the Terraform state which causes the next Terraform plan to propose recreating the resource. For resource APIs that support soft delete (grace time period before the resource is fully deleted), the `x-speakeasy-soft-delete-property` annotation adds a check against a read response property to also propose resource recreation.

For managed resources, any `x-speakeasy-soft-delete-property` attribute is omitted from the schema and state. For data resources, the attribute remains to preserve client-side filtering capabilities.

In this example, the resource will be proposed for recreation if the `deleted_at` property has a value:

```yaml
paths:
  "/example":
    get:
      x-speakeasy-entity-operation: Example#read
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schema/ExampleGetResponse"
components:
  schemas:
    ExampleGetResponse:
      type: object
      properties:
        # ...
        deleted_at:
          type: string
          format: date-time
          x-speakeasy-soft-delete-property: true
```

## Property Customization

### Remap API Property to Terraform Attribute Name

The `x-speakeasy-name-override` annotation adjusts the Terraform attribute name within a resource while remapping all the API data handling internally. This is useful, for example, to standardize differing API property names across operations to a single attribute name.

```yaml
unique_id:
  type: string
  x-speakeasy-name-override: id
```

The annotation also has other SDK customization capabilities, however, those are generally unnecessary for Terraform providers as the generated Go SDK is internal to the provider code.

### Align API Parameter With Terraform Property

The `x-speakeasy-match` annotation adjusts the API parameter name to align with a Terraform state property. If mismatches occur, a generation error will highlight appropriate root-level properties for accurate mapping.

```yaml
paths:
  /pet/{petId}:
    delete:
      parameters:
        - name: petId
          x-speakeasy-match: id
      x-speakeasy-entity-operation: Pet#delete
```

### Customize Status Codes for Missing Resources

By default, Terraform removes a resource from state when a Read operation returns an HTTP 404 Not Found status code. However, some APIs use different status codes to indicate a resource is missing or has been deleted, such as 403 Forbidden or 410 Gone.

The `x-speakeasy-entity-missing-codes` extension allows you to specify additional HTTP status codes that should trigger resource removal during Read operations. Apply this extension at the operation level on Read endpoints.

```yaml
paths:
  "/pet/{petId}":
    get:
      x-speakeasy-entity-operation: Pet#read
      x-speakeasy-entity-missing-codes:
        - 403
        - 410
      parameters:
        - name: petId
          in: path
          required: true
          schema:
            type: string
      responses:
        "200":
          description: Successful response
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Pet"
        "403":
          description: Forbidden - resource has been deleted
        "404":
          description: Not found
        "410":
          description: Gone - resource permanently deleted
```

When any of the specified status codes are returned during a Read operation, Terraform will automatically remove the resource from state and propose recreation on the next plan. The 404 status code is always checked by default, so you only need to specify additional codes.

### Property Defaults

Setting a property default value that matches your API responses when unconfigured will enhance the Terraform plan to include the known value, rather than propagate the value as unknown `(known after apply)` during creation and updates.

Speakeasy generation automatically adds a Terraform schema attribute default with OAS `default` value, for each of the following OAS types:

| OAS Schema Type | OAS default Support |
|-----------------|---------------------|
| `array` | Partial (`[]` and values of `boolean`/`number`/`string` item types only) |
| `boolean` | Yes |
| `map` | No |
| `number` | Yes |
| `object` | Partial (`null` only) |
| `oneOf` | No |
| `string` | Yes |

#### Custom Defaults

For unsupported or advanced use cases, the Terraform SDK supports calling schema-defined custom default logic. Create the custom code implementing the Terraform type-specific `resource/schema/defaults` package interface in any code location and use the OAS `x-speakeasy-terraform-custom-default` extension to reference that implementation in the schema definition.

In this example, a custom string default implementation is created in `internal/customdefaults/example.go`:

```go
package customdefaults

import (
  "context"

  "github.com/hashicorp/terraform-plugin-framework/resource/schema/defaults"
  "github.com/hashicorp/terraform-plugin-framework/types"
)

func Example() defaults.String {
  return exampleDefault{}
}

type exampleDefault struct{}

func (d exampleDefault) Description(ctx context.Context) string {
  return "Example custom default description"
}

func (d exampleDefault) MarkdownDescription(ctx context.Context) string {
  return "Example custom default description"
}

func (d exampleDefault) DefaultString(ctx context.Context, req defaults.StringRequest, resp *defaults.StringResponse) {
  resp.PlanValue = types.StringValue("example custom default")
}
```

With the following OAS configuration on the target property:

```yaml
example:
  type: string
  x-speakeasy-terraform-custom-default:
    imports:
      - github.com/examplecorp/terraform-provider-examplecloud/internal/customdefaults
    schemaDefinition: customdefaults.Example()
```

The `imports` configuration is optional if the custom code is within the `internal/provider` package and does not require additional imports.

### Hide Sensitive Properties

Properties marked as `x-speakeasy-param-sensitive` will be concealed from the console output of Terraform. This helps to ensure the confidentiality of sensitive data within Terraform operations.

```yaml
components:
  schemas:
    Pet:
      type: object
      properties:
        name:
          type: string
        secret:
          type: string
          x-speakeasy-param-sensitive: true
```

### Write Only

Mark a schema attribute as a write only argument (`WriteOnly: true` in the schema definition) with the `x-speakeasy-terraform-write-only` extension. Write only functionality prevents values from ever being exposed in plan or state data as a more complete secret value solution over sensitive attributes.

> **Warning:** Write only functionality is only supported in Terraform/OpenTofu 1.11 and later. Using it on earlier versions of Terraform/OpenTofu will result in a configuration error.

```yaml
components:
  schemas:
    Pet:
      type: object
      properties:
        name:
          type: string
        secret:
          type: string
          x-speakeasy-terraform-write-only: true
```

### Deprecation

Add OAS `deprecated: true` within a property to automatically return a warning diagnostic with a generic deprecation message when the property is configured in Terraform. Customize the messaging with the OAS `x-speakeasy-deprecation-message` extension.

> **Info:** Terraform always returns deprecation warnings for configured properties, but has limitations for displaying these warnings with response-only properties that are referenced elsewhere in the configuration.

In this example, Terraform will display a warning diagnostic with `Custom deprecation message` if the property is configured:

```yaml
example:
  type: string
  deprecated: true
  x-speakeasy-deprecation-message: Custom deprecation message
```

### Exclude Property From Terraform State

When `x-speakeasy-terraform-ignore: true`, this extension ensures the specified property and any interactions involving it are omitted from Terraform's state management.

> **Info:** This extension completely suppresses the property from the Terraform state. If you want to suppress a specific operation, use `x-speakeasy-ignore: true` to omit the operation from the annotated CRUD method. For example, if a field is present in both the `CREATE` and `READ` response bodies, omitting it from the `READ` response body will turn off drift detection for that field. The field will remain in the `CREATE` response body and the Terraform state.

```yaml
components:
  schemas:
    Pet:
      x-speakeasy-entity: Pet
      type: object
      properties:
        optionalMetadata:
          x-speakeasy-terraform-ignore: true
          type: string
        name:
          type: string
      required:
        - name
```

```hcl
resource "petstore_pet" "mypet" {
  name = "myPet"
  # Attempting to set an ignored parameter results in an error
  # optionalMetadata = true
}
```

### Custom Types

Set the `x-speakeasy-terraform-custom-type` extension to switch a property from the terraform-plugin-framework base type (e.g. `types.String`) to a custom type. Custom types typically include format-specific validation logic (such as a baked-in regular expression) or semantic equality handling to prevent unintentional value differences (such as ignoring inconsequential whitespace).

The following terraform-plugin-framework base types are supported for custom types:

- `Bool`
- `Float32`
- `Float64`
- `Int32`
- `Int64`
- `List`
- `Map`
- `Set`
- `String`

In this example, the `ipv4_address` string property will use the custom `iptypes.IPv4Address` type:

```yaml
ipv4_address:
  type: string
  x-speakeasy-terraform-custom-type:
    imports:
      - github.com/hashicorp/terraform-plugin-framework-nettypes/iptypes
    schemaType: "iptypes.IPv4AddressType{}"
    valueType: iptypes.IPv4Address
```

#### Implementing Custom Types

When built-in types or community types don't meet your needs, implement custom types in Go. Common use cases include:

- **Semantic equality** - RFC3339 dates that should compare equal regardless of timezone format
- **Value normalization** - URLs or paths that should be canonicalized
- **Custom validation** - Values with format requirements beyond JSON Schema

**Step 1: Create the type file**

Create `internal/provider/customtypes/rfc3339_type.go`:

```go
package customtypes

import (
    "context"
    "fmt"
    "time"

    "github.com/hashicorp/terraform-plugin-framework/attr"
    "github.com/hashicorp/terraform-plugin-framework/diag"
    "github.com/hashicorp/terraform-plugin-framework/types/basetypes"
    "github.com/hashicorp/terraform-plugin-go/tftypes"
)

// RFC3339Type is a custom type for RFC3339 timestamps with semantic equality.
type RFC3339Type struct {
    basetypes.StringType
}

func (t RFC3339Type) Equal(o attr.Type) bool {
    other, ok := o.(RFC3339Type)
    if !ok {
        return false
    }
    return t.StringType.Equal(other.StringType)
}

func (t RFC3339Type) ValueFromString(ctx context.Context, in basetypes.StringValue) (basetypes.StringValuable, diag.Diagnostics) {
    return RFC3339{StringValue: in}, nil
}

func (t RFC3339Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
    attrValue, err := t.StringType.ValueFromTerraform(ctx, in)
    if err != nil {
        return nil, err
    }
    stringValue, ok := attrValue.(basetypes.StringValue)
    if !ok {
        return nil, fmt.Errorf("unexpected value type of %T", attrValue)
    }
    return RFC3339{StringValue: stringValue}, nil
}

// RFC3339 is the value type for RFC3339 timestamps.
type RFC3339 struct {
    basetypes.StringValue
}

func (v RFC3339) Type(ctx context.Context) attr.Type {
    return RFC3339Type{}
}

// Equal returns true if the two values represent the same timestamp.
func (v RFC3339) Equal(o attr.Value) bool {
    other, ok := o.(RFC3339)
    if !ok {
        return false
    }

    // Handle null/unknown states
    if v.IsNull() || other.IsNull() || v.IsUnknown() || other.IsUnknown() {
        return v.StringValue.Equal(other.StringValue)
    }

    // Parse and compare as timestamps (semantic equality)
    t1, err1 := time.Parse(time.RFC3339, v.ValueString())
    t2, err2 := time.Parse(time.RFC3339, other.ValueString())

    if err1 != nil || err2 != nil {
        // Fall back to string comparison if parsing fails
        return v.StringValue.Equal(other.StringValue)
    }

    return t1.Equal(t2)
}

// Helper constructors
func NewRFC3339Null() RFC3339 {
    return RFC3339{StringValue: basetypes.NewStringNull()}
}

func NewRFC3339Unknown() RFC3339 {
    return RFC3339{StringValue: basetypes.NewStringUnknown()}
}

func NewRFC3339ValueMust(value string) RFC3339 {
    return RFC3339{StringValue: basetypes.NewStringValue(value)}
}
```

**Step 2: Reference in overlay**

```yaml
# overlay-entity.yaml
- target: $.components.schemas.MyEntity.properties.created_at
  update:
    x-speakeasy-terraform-custom-type:
      imports:
        - "github.com/yourorg/terraform-provider-x/internal/provider/customtypes"
      schemaType: customtypes.RFC3339Type{}
      valueType: customtypes.RFC3339
```

**Step 3: Add unit tests**

Create `internal/provider/customtypes/rfc3339_type_test.go`:

```go
func TestRFC3339TypeValueFromTerraform(t *testing.T) {
    testCases := map[string]struct {
        in          tftypes.Value
        expectation attr.Value
    }{
        "valid timestamp": {
            in:          tftypes.NewValue(tftypes.String, "2023-07-25T20:43:16+00:00"),
            expectation: customtypes.NewRFC3339ValueMust("2023-07-25T20:43:16+00:00"),
        },
        "unknown": {
            in:          tftypes.NewValue(tftypes.String, tftypes.UnknownValue),
            expectation: customtypes.NewRFC3339Unknown(),
        },
        "null": {
            in:          tftypes.NewValue(tftypes.String, nil),
            expectation: customtypes.NewRFC3339Null(),
        },
    }
    // ... test implementation
}

func TestRFC3339SemanticEquality(t *testing.T) {
    // These should be equal (same instant, different formats)
    v1 := customtypes.NewRFC3339ValueMust("2023-07-25T20:43:16+00:00")
    v2 := customtypes.NewRFC3339ValueMust("2023-07-25T20:43:16Z")

    if !v1.Equal(v2) {
        t.Error("Expected timestamps to be semantically equal")
    }
}
```

> **When to use custom types vs diff suppressors:**
> - Use **custom types** when semantic equality is needed (dates, URLs, normalized values)
> - Use **diff suppressors** (`x-speakeasy-param-suppress-computed-diff`) for API inconsistencies where values aren't returned

### Schemaless Configuration (jsonencode Pattern)

For APIs with plugin or policy systems where configuration varies by type, use `x-speakeasy-type-override: any` to accept arbitrary JSON:

**When to use schemaless configuration:**
- Plugin/policy configuration that varies by plugin type
- API accepts arbitrary JSON blobs
- Schema would require constant updates with new plugin versions
- Third-party extensions with unknown structure

**In overlay:**

```yaml
# overlay-entity.yaml
- target: $.components.schemas.Policy.properties.configuration
  description: Configuration varies by policy type
  update:
    x-speakeasy-type-override: any

- target: $.components.schemas.Endpoint.properties.settings
  description: Endpoint settings are plugin-specific
  update:
    x-speakeasy-type-override: any
```

**In Terraform configurations:**

```hcl
resource "example_policy" "rate_limit" {
  name = "Rate Limiting"
  type = "rate-limiting"

  # Configuration is JSON - structure depends on policy type
  configuration = jsonencode({
    requests_per_second = 100
    burst_size          = 50
    key_type            = "ip"
  })
}

resource "example_endpoint" "backend" {
  name = "Backend API"
  type = "http-proxy"

  # Endpoint settings vary by endpoint type
  settings = jsonencode({
    target              = "https://api.example.com"
    connect_timeout_ms  = 5000
    read_timeout_ms     = 30000
    tls = {
      verify = true
      ca_cert = file("ca.pem")
    }
  })
}
```

**Best practices for schemaless fields:**

1. **Document expected structure** - Provide examples for each type in your provider documentation
2. **Use consistent naming** - Name the field `configuration`, `settings`, or `options` consistently
3. **Consider file-based configs** - For complex configurations:
   ```hcl
   configuration = file("policies/rate-limit.json")
   ```
4. **Validate at API level** - Rely on API validation rather than Terraform schema validation

### Allow JSON String Attributes

Set the `x-speakeasy-type-override` extension to `any` to convert the associated attribute to a JSON string. This allows for inline the specification of the attribute's value, accommodating attributes with variable or dynamic structures.

```yaml
components:
  schemas:
    Pet:
      x-speakeasy-entity: Pet
      type: object
      properties:
        deep:
          x-speakeasy-type-override: any
          type: object
          properties:
            object:
              type: object
              additionalProperties: true
              properties:
                in:
                  type: object
                  properties:
                    here:
                      type: string
        name:
          type: string
      required:
        - name
```

```hcl
resource "petstore_pet" "mypet" {
  name = "myPet"
  deep = jsonencode({
    object = {
      with = "anything"
      defined = true
    }
  })
}
```

### Suppress Unnecessary Plan Changes

Setting the `x-speakeasy-param-suppress-computed-diff` to true suppresses unnecessary Terraform plan changes for computed attributes that are not definitively known until after application. This is useful in scenarios where computed attributes frequently cause spurious plan changes.

```yaml
components:
  schemas:
    Pet:
      x-speakeasy-entity: Pet
      type: object
      properties:
        name:
          type: string
        status:
          x-speakeasy-param-suppress-computed-diff: true
          type: string
```

> **Warning:** Applying this modifier when `x-speakeasy-entity-operation: my_resource#read` is not defined may result in drift between the Terraform plan and remote state should updates to attributes happen outside of Terraform changes. Please only apply this when necessary.

## Provider Configuration

### Security

The generated Terraform Provider will automatically implement all global security, as defined in the OpenAPI Specification, via the root-level `security` property and its associated `securitySchemes` components. Multiple security options are supported.

| Authentication Mechanism | Terraform Support |
|-------------------------|-------------------|
| HTTP Basic | ✅ |
| HTTP Bearer | ✅ |
| API Key | ✅ Header and Query |
| OAuth 2 | ✅ Client Credentials flow |
| Custom security schemes | ✅ Fully customizable |

In this example, the generated provider requires a bearer authentication token using an `access_token` provider-level attribute:

```yaml
components:
  securitySchemes:
    accessToken:
      type: http
      scheme: bearer
security:
  - accessToken: []
```

Refer to the Configuring environment variables section to optionally enable the fallback environment variable configuration of the value.

Operation-level security is also supported where it is implemented per-resource, however it is not recommended. Instead, we recommend implementing separate providers for each security layer. Terraform practitioners are conventionally used to the layering of provider implementations for this use case, and Terraform itself is designed around this separation of concerns.

### Server URL

Choose how the generated Terraform Provider will handle the server URL for API requests:

- Hardcoded server URL in Speakeasy generation configuration (`gen.yaml` file `generation` section `baseServerUrl` property) and not configurable in Terraform configurations.
- As defined in the OpenAPI Specification, via the root-level `servers` property. The generation will automatically handle:
  - Creating a `server_url` attribute that defaults to the first defined `url` value and is configurable in Terraform configurations.
  - Creating server URL variable attributes that default to their defined `default` values and are configurable in Terraform configurations.

> **Use single server URL:** It is recommended to use a single server URL for Terraform generation. Setting up multiple server URLs will create potentially confusing configuration options for Terraform consumers since variables across all server URLs are exposed.

In this example, the provider configuration is generated with configurable `location` and `server_url` attributes:

```yaml
servers:
  - url: https://{location}.example.com
    variables:
      location:
        default: production
```

Refer to the Configuring environment variables section to optionally enable the fallback environment variable configuration of the value(s).

Path-level and operation-level servers are also supported where it is implemented per-resource, however it is not recommended. Instead, we recommend implementing separate providers for each server layer.

### Globals

Use the `x-speakeasy-globals` extension to enable provider-level configuration of common properties across multiple resources. Global parameters are exposed as attributes on the Terraform `provider` block and are automatically applied to any API operation that declares them. This customization allows Terraform practitioners to configure a value in three ways:

- **Provider-level only:** The default value is applied to any resources that use the global.
- **Resource-level only:** The explicit value is applied only to those resource instance(s).
- **Provider-level with resource-level override:** The default value is applied to any resources that use the global, but any explicit resource-level configurations override the provider-level value.

In this example, the provider will accept an `organization_id` configuration as a global:

```yaml
x-speakeasy-globals:
  parameters:
    - name: organizationId
      in: path
      schema:
        type: string
```

The generated Terraform provider exposes the global as a configurable attribute:

```hcl
provider "examplecloud" {
  organization_id = "org-123"
}
```

#### Aligning Entity Fields With Global Parameters Using Name Overrides

For a global parameter to resolve automatically from provider configuration, the corresponding entity schema property name must match the global parameter name exactly. If they differ, add `x-speakeasy-name-override` to the entity property to make the names match.

> **Note:** Use `x-speakeasy-name-override` to align entity property names with global parameter names. Do not use `x-speakeasy-match` for this—`x-speakeasy-match` is for mapping operation parameters (for example, path parameters) to Terraform state properties. If names match via `x-speakeasy-name-override`, any `x-speakeasy-match` on the same parameter is redundant and can be removed.

**Example: Aligning a `workspace_id` global with an entity field**

Given a global parameter:

```yaml
x-speakeasy-globals:
  parameters:
    - name: workspace_id
      in: path
      schema:
        type: string
```

And an entity schema where the field has a different name:

```yaml
components:
  schemas:
    Workspace:
      x-speakeasy-entity: Workspace
      type: object
      properties:
        id:
          type: string
          description: The workspace identifier
        name:
          type: string
```

The entity property `id` does not match the global parameter name `workspace_id`, so the provider-level value will not be applied automatically. Add `x-speakeasy-name-override` to align the names:

```yaml
components:
  schemas:
    Workspace:
      x-speakeasy-entity: Workspace
      type: object
      properties:
        id:
          type: string
          description: The workspace identifier
          x-speakeasy-name-override: workspace_id
        name:
          type: string
```

With this override in place, the `workspace_id` global parameter value is taken from the provider configuration and used for the entity property. Any `x-speakeasy-match` that was only compensating for the naming mismatch is no longer needed:

```yaml
paths:
  /workspaces/{workspace_id}:
    get:
      x-speakeasy-entity-operation: Workspace#read
      parameters:
        - name: workspace_id
          in: path
          required: true
          schema:
            type: string
          # No x-speakeasy-match needed — the entity property name matches
          # the global via x-speakeasy-name-override
```

The resulting Terraform configuration uses the global seamlessly:

```hcl
provider "examplecloud" {
  workspace_id = "ws-abc123"
}

# workspace_id is automatically populated from the provider config
resource "examplecloud_workspace" "main" {
  name = "My Workspace"
}

# Individual resources can override the provider-level value
resource "examplecloud_workspace" "other" {
  workspace_id = "ws-xyz789"
  name         = "Other Workspace"
}
```

### Configuring Environment Variables

Use the `environmentVariables` configuration in the `gen.yaml` to set up an environment variable fallback for configuring provider attribute data. For example, the fallback may be accepting an access token value via an environment variable, rather than requiring an explicit `provider` block attribute configuration from Terraform practitioners.

```yaml
terraform:
  environmentVariables:
    - env: EXAMPLE_SERVER_URL_FROM_ENV_VAR
      providerAttribute: server_url
    - env: EXAMPLE_ACCESS_TOKEN
      providerAttribute: access_token
```

The `environmentVariables` configuration is expected to be a list of objects with `{env: string, providerAttribute: string}` keys and values. These associate environment variables (referenced as `env`) with provider attributes (referenced as `providerAttribute`).

### Additional Provider Configurations

Use the `additionalProviderAttributes` configuration in the `gen.yaml` file to enable Terraform configurations to specify additional provider-wide customizations. For example:

```yaml
terraform:
  additionalProviderAttributes:
    # ... configuration ...
```

#### Custom HTTP Headers

Set the `httpHeaders` configuration with the desired attribute name to enable Terraform configurations to map additional HTTP headers for all HTTP requests.

In this example, HTTP header customization is enabled using the `http_headers` provider attribute name:

```yaml
terraform:
  additionalProviderAttributes:
    httpHeaders: http_headers
```

This configuration enables a provider configuration, such as:

```hcl
provider "examplecloud" {
  http_headers = {
    "X-Example-Header" = "example-value"
  }
}
```

#### Skip TLS Verification

Set the `tlsSkipVerify` configuration with the desired attribute name to enable Terraform configurations to specify a Boolean to disable TLS verification in the HTTP client.

In this example, TLS verification customization is enabled using the `tls_skip_verify` provider attribute name:

```yaml
terraform:
  additionalProviderAttributes:
    tlsSkipVerify: tls_skip_verify
```

This configuration enables a provider configuration, such as:

```hcl
provider "examplecloud" {
  tls_skip_verify = true
}
```

### Custom Resources or Data Sources

To include an existing resource that is outside of the Speakeasy-generated provider, reference it in `gen.yaml` as follows:

```yaml
terraform:
  additionalResources:
    - importAlias: custom
      importLocation: github.com/custom/terraform-provider-example/src/custom_resource
      resource: custom.NewCustomResource
  additionalDataSources:
    - importAlias: custom
      importLocation: github.com/custom/terraform-provider-example/src/custom_datasource
      datasource: custom.NewCustomDataSource
  additionalEphemeralResources:
    - importAlias: custom
      importLocation: github.com/custom/terraform-provider-example/src/custom_ephemeral_resource
      resource: custom.NewCustomEphemeralResource
```

The `additionalResources` key is expected to contain a list of `{ importLocation?: string, importAlias?: string, resource: string }` objects. Each `resource` is inserted into the provider-managed resource list. If `importLocation` or `importAlias` is defined, Speakeasy adds them to the import list at the top of the provider file. The value of `resource` is arbitrary text, and could contain a function invocation if desired.

The `additionalEphemeralResources` key follows the same syntax, but inserts ephemeral resources into the provider.

The `additionalDataSources` key follows the same syntax, but inserts data resources into the provider using `datasource` (instead of `resource`) as the value inserted into the list.

## Resource Configuration

### Resource Documentation

Speakeasy automatically generates provider and resource documentation that is compliant with the public Terraform Registry requirements via the HashiCorp-maintained `terraform-plugin-docs` tool. Speakeasy runs `terraform-plugin-docs` at the end of successful generations or manually run via `go generate ./...`.

The public Terraform Registry and `terraform-plugin-docs` tool both follow specific file layout conventions.

For resources, the following file conventions are used:

| File Convention | Example | Description | Generated By |
|----------------|---------|-------------|--------------|
| docs/data-sources/{name}.md | docs/data-sources/order.md | Data resource documentation rendered in public Terraform Registry. | terraform-plugin-docs |
| docs/resources/{name}.md | docs/resources/order.md | Managed resource documentation rendered in public Terraform Registry. | terraform-plugin-docs |
| examples/data-sources/{type}/data-source.tf | examples/data-sources/example_order/data-source.tf | Data resource example configuration added to documentation page. | Speakeasy |
| examples/resources/{type}/import.sh | examples/resources/example_order/import.sh | Managed resource terraform import CLI command added to documentation page. | Speakeasy |
| examples/resources/{type}/resource.tf | examples/resources/example_order/resource.tf | Managed resource example configuration added to documentation page. | Speakeasy |

The `terraform-plugin-docs` tool also supports its own advanced use case customization, such as custom templates. Refer to the `terraform-plugin-docs` documentation for more information about those capabilities.

#### Resource Description

The `x-speakeasy-entity-description` extension modifies the description of a Terraform data or managed resource. This is useful when augmenting the documentation for specific resources in an OpenAPI document. This documentation is expected to be in Markdown format. Use this extension alongside the `x-speakeasy-entity` extension.

In this example, an order managed resource will have `Manage a coffee order.` written as the description in the resource code for any consuming tools, including documentation written by `terraform-plugin-docs` into `docs/resources/order.md`:

```yaml
components:
  schemas:
    Order:
      description: An order helps you make coffee
      x-speakeasy-entity: Order
      x-speakeasy-entity-description: |
        Manage a coffee order.
```

#### Resource Example

Example resource configuration is based on the OpenAPI Specification for API operation request and response data schemas. Speakeasy only generates example configuration for configurable properties. Example configuration values use the property `example` field when available or, as a fallback, use a generated value of the expected type following any `enum` or validation fields.

Fully customize the example resource configuration by using Speakeasy code customization capabilities.

For example, to manually manage and update the example configuration for a managed resource:

- Edit root directory `.genignore` file with an entry for `examples/resources/{type}/resource.tf`
- Edit `examples/resources/{type}/resource.tf` as necessary
- Run `go generate ./...` or Speakeasy generation to update `docs/resources/{name}.md`

### Resource Version

> **Use state upgraders sparingly:** State upgraders should be seldomly used for breaking schema type changes for existing state data. For adding/removing attributes, state upgraders are not needed and should be avoided.

The `x-speakeasy-entity-version` extension specifies the version of a given resource and should **only** be used if you need to write a state migrator, for instance, if you are changing the type of a field.

Terraform resource versions are zero-indexed and default to `0`. For your first breaking change requiring a state migrator, set `x-speakeasy-entity-version: 1`. Each state migrator function must migrate from the previous version of the state.

If this is set, a boilerplate state upgrader will be written and hooked into `internal/stateupgraders/your_resource_v1.go`. Please refer to the Terraform documentation for guidance on writing a state migrator.

## Validation and Dependencies

### Prevent Conflicting Attributes

The `x-speakeasy-conflicts-with` extension indicates that a property conflicts with another, ensuring that certain combinations of properties are not set together. This is ideal for situations where certain attributes are mutually exclusive or setting one attribute invalidates another.

```yaml
components:
  schemas:
    Pet:
      x-speakeasy-entity: Pet
      type: object
      properties:
        name:
          type: string
        name_prefix:
          type: string
          x-speakeasy-conflicts-with: name
        id:
          type: string
        generated_name_options:
          type: object
          properties:
            prefix:
              type: string
              x-speakeasy-conflicts-with:
                - ../name_prefix
                - ../name
                - ../id
```

### Enforce Mutually Exclusive Attributes

The `x-speakeasy-xor-with` extension ensures that exactly one of the listed attributes must be configured at the same time. If multiple attributes are set simultaneously or if no attribute is set, Terraform plan validation fails. This differs from `x-speakeasy-conflicts-with` in that it requires exactly one attribute to be set, while `conflicts-with` allows zero or one attribute to be set.

```yaml
components:
  schemas:
    Pet:
      x-speakeasy-entity: Pet
      type: object
      properties:
        this:
          type: string
        that:
          type: string
        another:
          type: string
          # user MUST configure exactly one of: this, that, or another
          x-speakeasy-xor-with:
            - ../this
            - ../that
```

### Enforce Required Attribute Dependencies

The `x-speakeasy-required-with` extension ensures that when the annotated field is configured, all the specified dependent fields must also be configured. This is useful for enforcing that certain fields are always configured together.

```yaml
components:
  schemas:
    Pet:
      x-speakeasy-entity: Pet
      type: object
      properties:
        name:
          type: string
        age:
          type: integer
        breed:
          type: string
          # when breed is set, name and age must also be set
          x-speakeasy-required-with:
            - ../name
            - ../age
```

### OpenAPI Plan Validators

Speakeasy automatically generates certain Terraform configuration value validation handlers based on your OpenAPI specification. When configuration validation is defined, Terraform raises invalid value errors before users can apply their configuration for a better user experience.

By default, these OpenAPI specification properties are automatically handled:

- For `string` types: `enum`, `maxLength`, `minLength`, and `pattern`
- For `integer` types: `enum`, `minimum`, and `maximum`
- For `array` types: `maxItems`, `minItems`, and `uniqueItems`

For use cases not automatically handled, add custom validation logic or reach out to the team.

#### Add Custom Validation Logic

Use the `x-speakeasy-plan-validators` extension to add custom validation logic to Terraform plan operations and ensure configurations meet predefined criteria before execution. This extension is essential for scenarios requiring advanced validation logic that JSON Schema cannot accommodate.

```yaml
components:
  schemas:
    Pet:
      type: object
      x-speakeasy-entity: Pet
      properties:
        name:
          type: string
        age:
          type: integer
          x-speakeasy-plan-validators: AgeValidator
```

In this scenario, when Speakeasy next generates the Terraform provider, it will bootstrap a custom validator file located at `internal/validators/int64validators/age_validator.go`, and import the schema configuration wherever `x-speakeasy-plan-validators: AgeValidator` is referenced. You can modify the validator file to contain your logic.

**Implementation Notes**

1. A plan validator is a type conformant to the `terraform-plugin-framework` expected interface. A unique plan validator will be bootstrapped in the appropriate subfolder for the Terraform type it is applied to: `boolvalidators`, `float64validators`, `int64validators`, `listvalidators`, `mapvalidators`, `numbervalidators`, `objectvalidators`, `setvalidators`, or `stringvalidators`. Speakeasy will always create and use a file as `snake_case.go` for a given `x-speakeasy-plan-validators` value.

2. A plan validator operates on the raw (untyped) Terraform value types. However, you can convert a Terraform type to a value type Speakeasy manages (`type_mytype.go`) by using the included reflection utility. This is useful for applying validators to complex types like `list`, `map`, `object`, and `set`.

3. While working with a plan validator, you have the ability to perform various tasks, including initiating network requests. However, it's important to ensure that plan validations do not result in any unintended side effects.

4. It is possible to have an array of plan validators, for example, `x-speakeasy-plan-validators: [MinAgeValidator, MaxAgeValidator]`.

5. A validator can only be applied to a resource attribute. Validators cannot be applied at the same level as the `x-speakeasy-entity` annotation because that becomes the "root" of the Terraform resource. However, validators can access or refer to any data in the entire resource. The annotation will be ignored for data sources.

6. Speakeasy regenerations do not delete user-written code. If the validator is no longer in use, it will be ignored (no longer referenced) but the source file will remain. You might want to delete such an orphaned validation file for repository hygiene.

## Plan Modification

### Custom Attribute Plan Modification

Attribute plan modifiers enable advanced default value, resource replacement, and difference suppression logic in managed resources. Due to the Terraform SDK implementation, attribute-level plan modifiers do not have access to provider-level configuration or the API client, however that SDK does support custom resource-level plan modification with implementing the `resource.ResourceWithModifyPlan` interface.

Use the `x-speakeasy-plan-modifiers` extension to add custom attribute-level plan modification logic to Terraform plan operations.

```yaml
components:
  schemas:
    Pet:
      type: object
      x-speakeasy-entity: Pet
      properties:
        name:
          type: string
        age:
          type: integer
          x-speakeasy-plan-modifiers: AgeModifier
```

In this scenario, when Speakeasy next generates the Terraform provider, it will bootstrap a custom plan modifier file, located at `internal/planmodifiers/int64planmodifier/age_modifier.go`, and import the schema configuration wherever `x-speakeasy-plan-modifiers: AgeModifier` is referenced.

The `x-speakeasy-plan-modifiers` extension supports an array of names as well, such as:

```yaml
x-speakeasy-plan-modifiers:
  - FirstPlanModifier
  - SecondPlanModifier
```

**Implementation Notes**

A plan modifier is a type that implements the plan modifier interface defined by the `terraform-plugin-framework`. A unique plan modifier is bootstrapped in the appropriate subfolder for the Terraform type that it is applied to, which is usually one of the following:

- `boolplanmodifiers`
- `float64planmodifiers`
- `int64planmodifiers`
- `listplanmodifiers`
- `mapplanmodifiers`
- `numberplanmodifiers`
- `objectplanmodifiers`
- `setplanmodifiers`
- `stringplanmodifiers`

A modifier can only be applied to a resource attribute. The annotation will be ignored for data sources. Modifiers cannot be applied at the same level as the `x-speakeasy-entity` annotation because that becomes the "root" of the Terraform resource.

Speakeasy regenerations do not delete user-written code. If the modifier is no longer in use, it will be ignored (no longer referenced) but the source file will remain. You might want to delete such an orphaned modifier file for repository hygiene.

## Advanced Features

### Specialty Annotations

The annotations in this section are not commonly used within Speakeasy. We recommend contacting our team to help you determine whether they are correct for you.

#### Force-marking a Property as Read-Only

The `x-speakeasy-param-readonly` extension marks a property as read-only. Any user attempt to modify it in Terraform will result in a runtime error. This prevents unintended changes to critical properties in Terraform configurations.

```yaml
components:
  schemas:
    Pet:
      type: object
      properties:
        name:
          type: string
        id:
          type: integer
          x-speakeasy-param-readonly: true
```

#### Force-designating a Property as Optional

Apply `x-speakeasy-param-optional` to any property to designate it as optional. This extension takes precedence over the required attribute in the JSON Schema specification, providing flexibility in Terraform configurations by allowing optional settings for certain properties.

```yaml
components:
  schemas:
    Pet:
      type: object
      properties:
        name:
          type: string
        id:
          type: integer
          x-speakeasy-param-optional: true
```

#### Forcing Resource Recreation on Property Change

Properties marked with `x-speakeasy-param-force-new` will cause the associated Terraform resource to be destroyed and recreated whenever the property value changes. This ensures that any alteration to the property triggers a complete recreation of the object.

```yaml
components:
  schemas:
    Pet:
      type: object
      properties:
        name:
          type: string
        id:
          type: integer
          x-speakeasy-param-force-new: true
```

#### Updating Behavior for Plan-Only Attributes

The `x-speakeasy-terraform-plan-only` extension ensures that only the values from the Terraform plan are used during updates, overriding any prior state or default values provided by the API. By preventing prior state values from being merged into the update request, the annotation ensures that omitted or null values in the plan are correctly reflected in API calls.

```yaml
components:
  schemas:
    Pet:
      type: object
      properties:
        properties:
        name:
          type: string
        id:
          type: integer
          nullable: true
          x-speakeasy-terraform-plan-only: true
```

### Deduplicating Terraform Types

The `terraform` types folder includes a representation of your data models that is appropriate for the `terraform-plugin-framework` type system. However, if you have multiple types with the same **signature** (for example, the same set of child property **types**), a lot of these types may be effectively duplicated. To minimize the Git repository and binary size, it might make sense to deduplicate these types by reusing types with the same signature across different resources. To enable this, set the following configuration option:

```yaml
terraform:
  enableTypeDeduplication: true
```

This option is `false` by default.

## Schema Keywords

> **Tip:** This section is not an exhaustive list of available keyword options. If you're unsure whether a keyword is supported, please reach out to our team at support@speakeasy.com.

### The anyOf Keyword

Terraform has limited support for the `anyOf` keyword due to its type system, which is less flexible than the JSON Schema type system. For instance, managing `anyOf` with multiple subtypes requires a large set of combined types, leading to practical and implementation challenges.

Consider replacing `anyOf` in the schema with `oneOf` or `allOf`. This adjustment aligns with Terraform's capabilities, namely, using `oneOf` for union types and `allOf` for intersection types.

For more guidance or to discuss schema adaptations, contact our support team at support@speakeasy.com.

### The oneOf Keyword

In Terraform, the `oneOf` keyword is defined as a `SingleNestedAttribute`, where each potential child is represented by a unique key. To ensure compliance with `oneOf` semantics, Speakeasy adds `conflicts-with` plan validators to confirm that only one of these keys is active at any given time.

If a `oneOf` keyword is declared at the root level of an entity, the Speakeasy generator extracts common property attributes and duplicates them into the root level. This is important if, for instance, a common `id` property is required for making read, update, or delete requests.

### The allOf Keyword

For the `allOf` keyword, Speakeasy merges all subschemas into a single combined attribute, creating a unified schema component that encapsulates all specified properties.

## Testing

Testing a Terraform Provider is critical for ensuring your customers are successfully able to write configurations that apply consistently without errors or unexpected behaviors.

There are two categories of Terraform Provider testing:

- Manual: Locally install the Terraform Provider with Terraform CLI configuration provider development overrides and run Terraform commands with individual configurations.
- Automated: Using native Go programming language testing functionality, automatically run Terraform configurations using real Terraform commands for provider code under development.

It is recommended to implement automated testing to simplify development and verification over time.

### Prerequisites

For both categories of testing, install the Terraform CLI where the testing will be ran. Locally, install via a package manager or binary download. On GitHub Actions, install via the `hashicorp/setup-terraform` action.

### Manual Testing

After generating a Terraform Provider using Speakeasy, the README file includes instructions for how to manually test with Terraform CLI provider development overrides. Those instructions are similar to the below.

In the repository root directory, build the provider binary:

```bash
go build .
```

Create or edit your Terraform CLI configuration file, such as `~/.terraformrc`, to point to your provider directory:

```hcl
provider_installation {
  dev_overrides {
    "registry.terraform.io/hashicorp/examplecloud" = "/path/to/terraform-provider-examplecloud"
  }
  direct {}
}
```

Change to any directory containing Terraform configurations for your provider and run Terraform commands such as `terraform apply`. The output should include a warning about the provider development overrides from the `~/.terraformrc` configuration.

### Automated Testing

> **Info:** Speakeasy intends to generate automated testing in the future, similar to SDKs. Over time, these steps will be automatically handled during generation.

Automated tests take Terraform configuration(s) and then perform create, read, import, update, and delete actions against those using real Terraform commands. Automated testing also supports writing assertions against the Terraform plan or state per test step. This is accomplished through the HashiCorp-maintained `github.com/hashicorp/terraform-plugin-testing` Go module. Refer to the Terraform Provider testing documentation for full details about capabilities.

There are a few steps required to get started:

- Add `github.com/hashicorp/terraform-plugin-testing` dependency to Speakeasy generation so it is automatically downloaded and installed.
- Create provider code to testing code mapping function.
- Create resource test files and configurations.
- Run automated testing.

#### Add Dependency

In `.speakeasy/gen.yaml`, add `github.com/hashicorp/terraform-plugin-testing` to the `terraform` section `additionalDependencies` configuration. View the latest Go package documentation for `terraform-plugin-testing` to retrieve the latest version number.

```yaml
terraform:
  # ... other configuration ...
  additionalDependencies:
    github.com/hashicorp/terraform-plugin-testing: v1.13.3
```

#### Provider Mapping Function

Create a shared function in `internal/provider/provider_test.go` to reference the provider during testing. Ensure the provider package import matches your Go module name and provider name in the mapping matches the provider type (short name).

```go
package provider_test

import (
  "github.com/hashicorp/terraform-plugin-framework/providerserver"
  "github.com/hashicorp/terraform-plugin-go/tfprotov6"
  "github.com/examplecorp/terraform-provider-examplecloud/internal/provider"
)

// Returns a mapping of provider type names to provider server implementations,
// suitable for acceptance testing via the ProtoV6ProtocolFactories field.
func testProviders() map[string]func() (tfprotov6.ProviderServer, error) {
  return map[string]func() (tfprotov6.ProviderServer, error){
    "examplecloud": providerserver.NewProtocol6WithError(provider.New("test")()),
  }
}
```

#### Resource Testing Files

Resource testing code is conventionally written as a Go test file (`internal/provider/xxx_resource_test.go`) while configurations are in `internal/provider/testdata` directories named after the test.

Create a resource test by creating a Go test file, such as `internal/provider/thing_resource_test.go`. Modify the configuration and checks as necessary to match the resource implementation.

```go
package provider_test

import (
  "regexp"
  "testing"

  "github.com/hashicorp/terraform-plugin-testing/config"
  "github.com/hashicorp/terraform-plugin-testing/helper/acctest"
  "github.com/hashicorp/terraform-plugin-testing/helper/resource"
  "github.com/hashicorp/terraform-plugin-testing/knownvalue"
  "github.com/hashicorp/terraform-plugin-testing/statecheck"
  "github.com/hashicorp/terraform-plugin-testing/tfjsonpath"
)

// Verifies the create, read, import, update, and delete lifecycle of the
// `examplecloud_thing` resource.
func TestThingResource_lifecycle(t *testing.T) {
  t.Parallel()

  randomName := "test-" + acctest.RandString(10)
  resourceAddress := "examplecloud_thing.test"

  resource.Test(t, resource.TestCase{
    ProtoV6ProviderFactories: testProviders(),
    Steps: []resource.TestStep{
      // Verifies resource create and read.
      {
        ConfigDirectory: config.TestNameDirectory(),
        ConfigVariables: config.Variables{
          "name": config.StringVariable(randomName+"-original"),
        },
        // Check computed values.
        ConfigStateChecks: []statecheck.StateCheck{
          statecheck.ExpectKnownValue(
            resourceAddress,
            tfjsonpath.New("id"),
            knownvalue.StringRegexp(regexp.MustCompile(`^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)),
          ),
        },
      },
      // Verifies resource import.
      {
        ConfigDirectory: config.TestNameDirectory(),
        ConfigVariables: config.Variables{
          "name": config.StringVariable(randomName+"-original"),
        },
        ResourceName:      resourceAddress,
        ImportState:       true,
        ImportStateVerify: true,
      },
      // Verifies resource update.
      {
        ConfigDirectory: config.TestNameDirectory(),
        ConfigVariables: config.Variables{
          "name": config.StringVariable(randomName+"-updated"),
        },
      },
      // Testing framework implicitly verifies resource delete.
    },
  })
}
```

Create the associated testing configuration in `internal/provider/testdata/TestThingResource_lifecycle/main.tf`:

```hcl
variable "name" {
  type = string
}

resource "examplecloud_thing" "test" {
  name = var.name
}
```

#### Run Automated Testing

> **Note:** Ensure Speakeasy generation, such as `speakeasy run`, has been run at least once beforehand to ensure the `github.com/hashicorp/terraform-plugin-testing` dependency is downloaded and installed. Verify via `go.mod` file contents.

Run automated testing via native Go programming language testing functionality, such as the `go test` command. The `github.com/hashicorp/terraform-plugin-testing` Go module requires the `TF_ACC` environment variable to set, conventionally to `1` (enabled). Depending on your provider configuration requirements, you may also need to set other security or server URL environment variables.

Run the following commands to perform the automated testing:

```bash
# required once per session
export TF_ACC=1

# ... export any required provider configuration environment variables ...

go test -count=1 -timeout=10m -v ./...
```

The testing library will handle all the underlying details to run the provider code, call Terraform commands, and verify assertions.

Run individual tests with the `-run` flag, which accepts a regular expression pattern. For example:

```bash
go test -count=1 -run='TestThingResource_lifecycle' -timeout=10m -v ./...
```

## Common Troubleshooting and Recipes

When generating Terraform providers from OpenAPI documents, you might encounter cases where your API's structure doesn't naturally fit Terraform's resource-oriented approach. These differences typically occur because APIs aren't always designed with Terraform's infrastructure management style in mind.

Speakeasy's generator identifies these design differences and offers extensions and customization options to address them. This enables you to produce effective Terraform providers, even when your API doesn't initially match Terraform's requirements, simplifying what might otherwise be challenging configuration tasks.

### Fixing Common API Issues

#### Impedance Mismatch Errors

An impedance mismatch error happens when Speakeasy's generator finds properties with different data types that need to be combined into one. This error means the data types don't match up correctly across API operations (such as between request and response data or across different operations for the same entity), which can cause problems in the Terraform provider being created.

A typical impedance mismatch scenario occurs in the following situation:

- A request takes a UUID string for task assignment:

    ```json
    {
      "taskId": "12345",
      "assignee": "user-uuid-1"
    }
    ```

- The response returns a full user object for that assignee:

    ```json
    {
      "taskId": "12345",
      "assignee": {
        "id": "user-uuid-1",
        "name": "Alice Johnson"
      }
    }
    ```

When the generator attempts to merge these properties, it detects that it cannot reconcile the different data types (string vs object) and yields an impedance mismatch error.

#### How to Fix an Impedance Mismatch Error

Speakeasy includes built-in extensions to help fix impedance mismatch errors. You can use these solutions to adjust either the request or the response data:

**Option 1: Override the property name**

Use `x-speakeasy-name-override` to give the mismatched properties different names so they no longer attempt to merge:

```yaml
TaskRequest:
  type: object
  x-speakeasy-entity: Task
  properties:
    taskId:
      type: string
    assignee:
      type: string
      x-speakeasy-name-override: assigneeId # Override the name to avoid merging
```

With this approach, the additional data (stored in the `assignee` response field) is still available to Terraform consumers. However, there may be a loss of drift detection when Terraform updates the resource's state during the read operation.

**Note:** You can also use `x-speakeasy-name-override` to rename the conflicting property (in this case, "assignee") in the response schema to achieve the same effect. The key is to prevent a type collision between request and response.

**Option 2: Ignore the mismatched property**

Use `x-speakeasy-ignore` to exclude the problematic property from generation:

```yaml
TaskResponse:
  type: object
  x-speakeasy-entity: Task
  properties:
    taskId:
      type: string
    assignee:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
      x-speakeasy-ignore: true # Ignore this property in the response
```

This approach resolves the impedance mismatch by removing the conflicting property altogether. However, this also means that the property is no longer tracked in Terraform state.

## Advanced Overlay Workflows

For complex APIs with multiple resource types, use a **multi-overlay strategy** rather than a single monolithic overlay. This pattern is used by production providers like PlanetScale to manage sophisticated Terraform configurations.

### Multi-Overlay Strategy

Structure overlays as separate files organized by purpose:

1. **Base overlay** - Global configuration (retries, validation fixes, shared settings)
2. **Terraform overlay** - Provider-level settings (security schemes, global security)
3. **Entity overlays** - One per resource/data source with entity-specific transformations
4. **Cleanup overlay** - Final transformations (remove deprecated paths, clean up)

**workflow.yaml Example:**

```yaml
workflowVersion: 1.0.0
speakeasyVersion: 1.675.1
sources:
  MyAPI:
    inputs:
      - location: schemas/openapi.yaml
    overlays:
      - location: schemas/overlay-base.yaml              # Global settings
      - location: schemas/overlay-users.yaml             # User resource
      - location: schemas/overlay-projects.yaml          # Project resource
      - location: schemas/overlay-databases.yaml         # Database resource
      - location: schemas/overlay-cleanup.yaml           # Final cleanup
    output: schemas/out.openapi.yaml
targets:
  myprovider:
    target: terraform
    source: MyAPI
```

#### Real-World Example: Confluent Provider (12 Overlays)

The Confluent Terraform provider organizes 12 overlays by domain:

```yaml
# .speakeasy/workflow.yaml
sources:
  Confluent Cloud APIs:
    inputs:
      - location: schemas/openapi.json
    overlays:
      # Layer 1: Global settings
      - location: schemas/overlay-base.yaml              # Retries, validation fixes
      - location: schemas/overlay-terraform.yaml         # Provider metadata, security

      # Layer 2: Domain-specific resources
      - location: schemas/overlay-terraform-cmk-cluster.yaml        # Kafka clusters
      - location: schemas/overlay-terraform-iam-api-key.yaml        # API keys
      - location: schemas/overlay-terraform-iam-role-binding.yaml   # Role bindings
      - location: schemas/overlay-terraform-iam-service-account.yaml # Service accounts
      - location: schemas/overlay-terraform-iam-user.yaml           # Users
      - location: schemas/overlay-terraform-kafka-cluster-link.yaml # Cluster links
      - location: schemas/overlay-terraform-kafka-topic.yaml        # Topics
      - location: schemas/overlay-terraform-org-environment.yaml    # Environments
      - location: schemas/overlay-terraform-networking-network.yaml # Networks
      - location: schemas/overlay-terraform-srcm-cluster.yaml       # Schema Registry
```

**Overlay responsibilities:**

| Overlay | Responsibility |
|---------|---------------|
| `overlay-base.yaml` | Global retries, x-extensible-enum conversion, validation fixes |
| `overlay-terraform.yaml` | Custom security scheme, provider info, global security |
| `overlay-terraform-{domain}.yaml` | Entity operations, polling, transforms, field filtering |

**Base overlay pattern (global retries):**

```yaml
# schemas/overlay-base.yaml
overlay: 1.0.0
info:
  title: Base API overlay
actions:
  - target: $
    update:
      x-speakeasy-retries:
        strategy: backoff
        backoff:
          initialInterval: 500
          maxInterval: 10000
          maxElapsedTime: 600000
          exponent: 1.5
        statusCodes:
          - 429
          - 5XX
        retryConnectionErrors: true
```

**Entity overlay pattern (IAM API Key):**

```yaml
# schemas/overlay-terraform-iam-api-key.yaml
overlay: 1.0.0
x-speakeasy-jsonpath: rfc9535
info:
  title: Terraform api_key(s) resources overlay
actions:
  # Ignore pagination parameters
  - target: $.paths["/iam/v2/api-keys"].get.parameters[?@.name == 'page_size']
    update:
      x-speakeasy-terraform-ignore: true

  # Define CRUD operations
  - target: $.paths["/iam/v2/api-keys"].post
    update:
      x-speakeasy-entity-operation: ApiKey#create

  - target: $.paths["/iam/v2/api-keys/{id}"].get
    update:
      x-speakeasy-entity-operation: ApiKey#read

  - target: $.paths["/iam/v2/api-keys/{id}"].patch
    update:
      x-speakeasy-entity-operation:
        - entityOperation: ApiKey#update
          options:
            patch:
              style: only-send-changed-attributes

  - target: $.paths["/iam/v2/api-keys/{id}"].delete
    update:
      x-speakeasy-entity-operation: ApiKey#delete

  # Define entity schema
  - target: $.components.schemas["iam.v2.ApiKeySpec"]
    update:
      x-speakeasy-entity: ApiKey

  # Ignore API metadata from Terraform state
  - target: $.components.schemas["iam.v2.ApiKey"].properties
    update:
      metadata:
        x-speakeasy-terraform-ignore: true
```

> **Pattern Source:** Extracted from [speakeasy-sdks/terraform-provider-confluent](https://github.com/speakeasy-sdks/terraform-provider-confluent) - Production multi-overlay architecture

### Path Copying for Similar Resources

When your API has similar endpoints for different resource types (e.g., MySQL vs PostgreSQL branches, different storage backends), use path copying to create variants:

```yaml
overlay: 1.1.0
x-speakeasy-jsonpath: rfc9535
info:
  title: PostgreSQL-specific overlay
actions:
  # Create a new path by copying an existing one
  - target: $.paths
    update:
      /databases/{database}/branches#postgres: {}

  - target: $.paths['/databases/{database}/branches#postgres']
    description: Copy branches path as base for postgres
    copy: $.paths['/databases/{database}/branches']

  # Customize the copied path
  - target: $.paths['/databases/{database}/branches#postgres'].post
    update:
      operationId: create_postgres_branch
      x-speakeasy-entity-operation: PostgresBranch#create
      x-speakeasy-entity-description: Manage a PostgreSQL database branch.
```

### Field Removal for Type-Specific Resources

Remove fields that don't apply to specific resource types:

```yaml
# Remove MySQL-only fields from PostgreSQL resource
- target: $.paths['/...#postgres'].post.responses['201'].content['application/json'].schema.properties.mysql_address
  remove: true

- target: $.paths['/...#postgres'].post.responses['201'].content['application/json'].schema.properties.vtgate_size
  remove: true

# Set type constraint for engine-specific responses
- target: $.paths['/...#postgres'].post.responses['201'].content['application/json'].schema.properties.kind
  update:
    const: postgresql
    description: The kind of branch (always postgresql for PostgreSQL branches)
```

### Custom Security Scheme via Overlay

Replace or customize security schemes for Terraform-specific authentication:

```yaml
overlay: 1.1.0
x-speakeasy-jsonpath: rfc9535
info:
  title: Base Terraform generation overlay
actions:
  - target: $.components.securitySchemes
    description: Add custom security scheme for Terraform Provider
    update:
      ServiceToken:
        type: http
        scheme: custom
        x-speakeasy-custom-security-scheme:
          schema:
            type: object
            properties:
              service_token:
                type: string
                description: API Service Token
              service_token_id:
                type: string
                description: API Service Token ID
            required:
              - service_token
              - service_token_id

  - target: $.security
    description: Replace default security with custom scheme
    remove: true

  - target: $
    update:
      security:
        - ServiceToken: []
```

#### Real-World Example: Confluent Cloud API Keys

The Confluent provider renames HTTP Basic auth to domain-friendly names:

```yaml
# overlay-terraform.yaml
- target: $.components.securitySchemes["cloud-api-key"]
  update:
    scheme: custom
    x-speakeasy-custom-security-scheme:
      schema:
        type: object
        properties:
          cloud_api_key:
            type: string
            description: Confluent Cloud API Key ID
          cloud_api_secret:
            type: string
            description: Confluent Cloud API Key Secret
        required:
          - cloud_api_key
          - cloud_api_secret
```

**Result in provider configuration:**

```hcl
provider "confluent" {
  cloud_api_key    = var.confluent_api_key
  cloud_api_secret = var.confluent_api_secret
}
```

Instead of generic `username`/`password`, users see domain-appropriate `cloud_api_key`/`cloud_api_secret`.

> **Pattern Source:** Extracted from [speakeasy-sdks/terraform-provider-confluent](https://github.com/speakeasy-sdks/terraform-provider-confluent)

### JQ Transforms for Complex Request Bodies

When the API request format differs significantly from the desired Terraform schema, use `x-speakeasy-transform-to-api` with JQ expressions to restructure request bodies.

#### When to Use JQ Transforms

- API expects array of name/value pairs but Terraform uses objects
- Nested credentials need special encoding (e.g., base64)
- Field names differ substantially between TF and API
- Complex conditional logic based on input field combinations
- Flattening/expanding nested structures

#### Basic Transform Syntax

```yaml
schema:
  type: object
  x-speakeasy-transform-to-api:
    jq: |
      {
        api_field: .terraform_field,
        nested: {
          value: .flat_field
        }
      }
  properties:
    terraform_field:
      type: string
    flat_field:
      type: string
```

#### Real-World Example: Kafka Cluster Links

The Confluent provider transforms Terraform-friendly nested objects into API format with credential encoding:

```yaml
# overlay-terraform-kafka-cluster-link.yaml
- target: $.components.requestBodies.CreateLinkRequest.content["application/json"]
  update:
    schema:
      type: object
      x-speakeasy-transform-to-api:
        jq: |
          (
            . as $in
            | ($in.source_kafka_cluster // null) as $src
            | ($in.destination_kafka_cluster // null) as $dest
            | ($in.local_kafka_cluster // null) as $local
            | ($in.remote_kafka_cluster // null) as $remote
            | (if $src then $src elif $dest then $dest elif $remote then $remote else null end) as $remoteBlock
            | (if $remoteBlock then ($remoteBlock.bootstrap_endpoint // $remoteBlock.rest_endpoint // null) else null end) as $ep
            | ($in.config // {}) as $usercfg
            | {
                data: (
                  ($usercfg | to_entries | map({name: .key, value: .value}))
                  + (if $remoteBlock.credentials then
                      [
                        {name: "sasl.jaas.config", value: ("org.apache.kafka.common.security.plain.PlainLoginModule required username=\"" + $remoteBlock.credentials.key + "\" password=\"" + $remoteBlock.credentials.secret + "\";")},
                        {name: "security.protocol", value: "SASL_SSL"},
                        {name: "sasl.mechanism", value: "PLAIN"}
                      ]
                    else []
                    end)
                  + (if $ep then [{name: "bootstrap.servers", value: $ep}] else [] end)
                )
              }
          )
      properties:
        source_kafka_cluster:
          type: object
          x-speakeasy-conflicts-with:
            - destination_kafka_cluster
            - local_kafka_cluster
            - remote_kafka_cluster
          properties:
            id:
              type: string
            bootstrap_endpoint:
              type: string
            credentials:
              type: object
              properties:
                key:
                  type: string
                secret:
                  type: string
        # ... additional properties
```

**Terraform configuration (user-friendly):**

```hcl
resource "confluent_cluster_link" "east_to_west" {
  link_name = "east-to-west-link"

  source_kafka_cluster {
    id                 = confluent_kafka_cluster.source.id
    bootstrap_endpoint = confluent_kafka_cluster.source.bootstrap_endpoint
    credentials {
      key    = confluent_api_key.source.id
      secret = confluent_api_key.source.secret
    }
  }

  config = {
    "consumer.offset.sync.enable" = "true"
  }
}
```

**Transformed API request:**

```json
{
  "data": [
    {"name": "consumer.offset.sync.enable", "value": "true"},
    {"name": "sasl.jaas.config", "value": "org.apache.kafka.common.security.plain.PlainLoginModule required username=\"api-key-id\" password=\"api-key-secret\";"},
    {"name": "security.protocol", "value": "SASL_SSL"},
    {"name": "sasl.mechanism", "value": "PLAIN"},
    {"name": "bootstrap.servers", "value": "pkc-xxxxx.us-east-1.aws.confluent.cloud:9092"}
  ]
}
```

#### JQ Transform Best Practices

1. **Start simple** - Build transforms incrementally, testing each step
2. **Use null coalescence** - Handle optional fields with `// null` or `// {}`
3. **Preserve user config** - Merge user-provided config with generated values
4. **Document the transform** - Add comments explaining the transformation logic
5. **Test edge cases** - Verify behavior when optional fields are missing

> **Pattern Source:** Extracted from [speakeasy-sdks/terraform-provider-confluent](https://github.com/speakeasy-sdks/terraform-provider-confluent) - Cluster link credential transformation

### Overlay Ordering and Precedence

Overlays are applied in the order listed in `workflow.yaml`. Later overlays can modify or override changes from earlier ones:

| Order | Overlay Type | Purpose |
|-------|--------------|---------|
| 1 | Base | Global settings, security, info |
| 2-N | Entity | Resource-specific transformations |
| Last | Cleanup | Remove deprecated paths, final fixes |

> **Tip:** Use descriptive overlay names like `overlay-terraform-{entity}.yaml` to make the structure clear.

### Generating Overlays from API Diffs

Use `speakeasy overlay compare` to automatically generate overlays when maintaining providers against evolving APIs. This is particularly useful when:

- Your API vendor updates their OpenAPI spec and you need to identify what changed
- You want to create an overlay from scratch by comparing a base spec with your desired modifications
- You need to audit differences between your local overlay and the remote API

**Basic usage:**

```bash
# Compare two local files
speakeasy overlay compare \
    --before original-openapi.yaml \
    --after modified-openapi.yaml \
    --out overlay-diff.yaml

# Compare remote API with local overlay (common for provider maintenance)
speakeasy overlay compare \
    --before https://api.example.com/openapi.yaml \
    --after terraform_overlay.yaml \
    --out overlay-diff.yaml
```

**Makefile integration pattern (from Opal provider):**

```makefile
# Generate overlay diff from remote API
.PHONY: overlay-diff
overlay-diff:
	speakeasy overlay compare \
		--before https://app.example.com/openapi.yaml \
		--after terraform_overlay.yaml \
		--out overlay-diff.yaml
```

**Workflow for API updates:**

1. Run `speakeasy overlay compare` to see what changed in the remote API
2. Review the generated diff overlay
3. Merge necessary changes into your existing overlay
4. Run `speakeasy run` to regenerate the provider

### Remote API Workflow Pattern

For providers built against third-party APIs, fetch the OpenAPI spec directly from the API vendor:

```yaml
# .speakeasy/workflow.yaml
workflowVersion: 1.0.0
speakeasyVersion: latest
sources:
  vendor-api:
    inputs:
      - location: https://api.vendor.com/openapi.yaml  # Remote spec
    overlays:
      - location: terraform_overlay.yaml               # Local customizations
    output: openapi.yaml                               # Merged output
targets:
  vendor-provider:
    target: terraform
    source: vendor-api
```

This pattern ensures your provider always builds against the latest API spec while preserving your Terraform-specific customizations.

## State Upgrader Implementation

When you make breaking schema changes (e.g., changing a field's type, restructuring nested objects), you must implement state upgraders to migrate existing Terraform state. Without proper migration, users will encounter errors when running `terraform plan` after upgrading.

### When State Upgraders Are Required

| Change Type | State Upgrader Needed |
|-------------|----------------------|
| Adding new attribute | No |
| Removing attribute | No (but may cause drift) |
| Changing attribute type (string → int) | **Yes** |
| Restructuring nested objects | **Yes** |
| Renaming attribute | **Yes** |
| Changing from optional to required | No (but may cause errors) |

### Configuring Entity Version

Set `x-speakeasy-entity-version` on your entity to trigger state upgrader generation:

```yaml
components:
  schemas:
    Group:
      x-speakeasy-entity: Group
      x-speakeasy-entity-version: 3  # Increment for each breaking change
      type: object
      properties:
        # ... properties
```

When you increment the version, Speakeasy generates a boilerplate state upgrader file at `internal/stateupgraders/{entity}_v{N-1}.go`.

### Implementing the State Upgrader

The generated boilerplate requires you to implement the migration logic. Here's a complete example based on the Opal provider's group state upgrader:

```go
// internal/stateupgraders/group_v0.go
package stateupgraders

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
)

// GroupV0 returns the state upgrader for migrating from v0 to v1.
func GroupV0() resource.StateUpgrader {
	return resource.StateUpgrader{
		// Define the PREVIOUS schema (v0)
		PriorSchema: &schema.Schema{
			Attributes: map[string]schema.Attribute{
				"id": schema.StringAttribute{},
				"name": schema.StringAttribute{},
				// Old field that's being changed
				"admin_owner_id": schema.StringAttribute{},
			},
		},
		StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
			// Parse the old state
			var rawState map[string]tftypes.Value
			if err := req.RawState.As(&rawState); err != nil {
				resp.Diagnostics.AddError(
					"State Migration Error",
					"Failed to parse prior state: "+err.Error(),
				)
				return
			}

			// Extract values from old state
			var id, name, adminOwnerID string
			if v, ok := rawState["id"]; ok && !v.IsNull() {
				v.As(&id)
			}
			if v, ok := rawState["name"]; ok && !v.IsNull() {
				v.As(&name)
			}
			if v, ok := rawState["admin_owner_id"]; ok && !v.IsNull() {
				v.As(&adminOwnerID)
			}

			// Build new state with transformed structure
			// Example: admin_owner_id moved to nested admin_owner.id
			newState := tftypes.NewValue(
				tftypes.Object{
					AttributeTypes: map[string]tftypes.Type{
						"id":   tftypes.String,
						"name": tftypes.String,
						"admin_owner": tftypes.Object{
							AttributeTypes: map[string]tftypes.Type{
								"id": tftypes.String,
							},
						},
					},
				},
				map[string]tftypes.Value{
					"id":   tftypes.NewValue(tftypes.String, id),
					"name": tftypes.NewValue(tftypes.String, name),
					"admin_owner": tftypes.NewValue(
						tftypes.Object{
							AttributeTypes: map[string]tftypes.Type{
								"id": tftypes.String,
							},
						},
						map[string]tftypes.Value{
							"id": tftypes.NewValue(tftypes.String, adminOwnerID),
						},
					),
				},
			)

			resp.DynamicValue, _ = tfprotov6.NewDynamicValue(
				newState.Type(),
				newState,
			)
		},
	}
}
```

### Chaining Multiple Upgrades

For multiple version migrations (e.g., v0 → v1 → v2 → v3), implement a state upgrader for each version transition. Terraform automatically chains them:

```go
// In your resource definition
func (r *GroupResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: stateupgraders.GroupV0(),  // v0 → v1
		1: stateupgraders.GroupV1(),  // v1 → v2
		2: stateupgraders.GroupV2(),  // v2 → v3
	}
}
```

### User Migration Scripts

For major version upgrades with complex state changes, consider providing a migration script (like Opal's `scripts/migration_script.py`) that helps users transform their Terraform configurations:

```python
#!/usr/bin/env python3
"""Migration script for terraform-provider-example v1.x → v2.x"""

import re
import sys

def migrate_hcl(content: str) -> str:
    # Transform old attribute names to new structure
    content = re.sub(
        r'admin_owner_id\s*=\s*"([^"]+)"',
        r'admin_owner {\n    id = "\1"\n  }',
        content
    )
    return content

if __name__ == "__main__":
    for filepath in sys.argv[1:]:
        with open(filepath, 'r') as f:
            content = f.read()
        migrated = migrate_hcl(content)
        with open(filepath, 'w') as f:
            f.write(migrated)
        print(f"Migrated: {filepath}")
```

## Terraform Configuration Options (gen.yaml)

This section details the available configuration options for Terraform Provider generation. All configuration is managed in the `gen.yaml` file under the `terraform` section.

### Version and General Configuration

```yaml
terraform:
  version: 1.2.3
  author: "examplecorp"
  packageName: "examplecloud"
```

| Name | Required | Default Value | Description |
|------|----------|---------------|-------------|
| version | true | 0.0.1 | Current version of the Terraform Provider. |
| packageName | true | terraform | Terraform Provider name. Prefixes all resource names. For providers published in the public Terraform Registry, this typically matches the suffix after terraform-provider- in the GitHub Repository name. |
| author | true | speakeasy | Terraform Provider namespace. For providers published in the public Terraform Registry, this typically matches the GitHub Organization name. |

### Additions

```yaml
terraform:
  additionalDependencies: {}
  additionalResources: []
  additionalDataSources: []
  additionalEphemeralResources: []
```

| Name | Required | Default Value | Description |
|------|----------|---------------|-------------|
| additionalDependencies | false | {} | Add additional dependencies to include in the generated `go.mod`. |
| additionalResources | false | [] | A list of `{ importLocation?: string, importAlias?: string, resource: string }` objects to insert into the provider resource list. |
| additionalDataSources | false | [] | A list of `{ importLocation?: string, importAlias?: string, datasource: string }` objects to insert into the provider data source list. |
| additionalEphemeralResources | false | [] | A list of `{ importLocation?: string, importAlias?: string, datasource: string }` objects to insert into the provider ephemeral resource list. |

### Environment Variables

```yaml
terraform:
  environmentVariables:
    - env: EXAMPLECLOUD_TOKEN
      providerAttribute: token
```

| Name | Required | Default Value | Description |
|------|----------|---------------|-------------|
| environmentVariables | false | [] | A list of objects with `[env: string, providerAttribute: string]` keys/values to associate environment variables with a provider attribute. |

---

## Pre-defined TODO List

When customizing a Terraform provider, initialize your TODO list with:

| Step | TODO Item | Active Form |
|------|-----------|-------------|
| 1 | Review customization requirements | Reviewing customization requirements |
| 2 | Add x-speakeasy extensions as needed | Adding x-speakeasy extensions |
| 3 | Configure property-level customizations | Configuring property customizations |
| 4 | Add validation rules with x-speakeasy-plan-validators | Adding validation rules |
| 5 | Configure plan modifiers if needed | Configuring plan modifiers |
| 6 | Test provider with terraform plan | Testing with terraform plan |
| 7 | Verify all customizations work correctly | Verifying customizations |

**Usage:**
```
TodoWrite([
  {content: "Review customization requirements", status: "pending", activeForm: "Reviewing customization requirements"},
  {content: "Add x-speakeasy extensions as needed", status: "pending", activeForm: "Adding x-speakeasy extensions"},
  {content: "Configure property-level customizations", status: "pending", activeForm: "Configuring property customizations"},
  {content: "Add validation rules with x-speakeasy-plan-validators", status: "pending", activeForm: "Adding validation rules"},
  {content: "Configure plan modifiers if needed", status: "pending", activeForm: "Configuring plan modifiers"},
  {content: "Test provider with terraform plan", status: "pending", activeForm: "Testing with terraform plan"},
  {content: "Verify all customizations work correctly", status: "pending", activeForm: "Verifying customizations"}
])
```

